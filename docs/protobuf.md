## Поддержка Protocol Buffers (Protobuf)

Внешняя компонента поддерживает работу с форматом **Protocol Buffers** (protobuf) - эффективным бинарным форматом сериализации данных от Google.

### Оглавление

| Метод | Описание |
|-------|----------|
| [СохранитьСхемуProtobuf](#сохранение-схемы-protobuf) | Сохранение .proto схемы |
| [ПреобразоватьВФорматProtobuf](#преобразование-json-в-protobuf) | Преобразование JSON в формат Protobuf |
| [ОтправитьСообщениеProtobuf](#асинхронная-отправка-protobuf) | Асинхронная отправка Protobuf в Kafka |
| [ОтправитьСообщениеProtobufСОжиданиемРезультата](#синхронная-отправка-protobuf) | Синхронная отправка Protobuf в Kafka |
| [СохранитьФайлProtobuf](#сохранение-protobuf-в-файл) | Сохранение Protobuf в файл |
| [ДекодироватьСообщениеProtobuf](#декодирование-protobuf-сообщения) | Декодирование Protobuf в JSON или двоичные данные |

---

### Сохранение схемы Protobuf

Сохранение .proto схемы, которая будет использоваться для **Protobuf**.

```1С
СохранитьСхемуProtobuf(ИмяСхемы, СхемаProto);
```

**ИмяСхемы** - Строка. Обязательный. Имя схемы для последующего использования.

**СхемаProto** - Строка. Обязательный. Содержимое .proto файла в текстовом формате. Пример схемы:

```protobuf
syntax = "proto3";

message User {
  string id = 1;
  string name = 2;
  string phone = 3;
  int32 age = 4;
}
```

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

Пример использования метода **СохранитьСхемуProtobuf**:

```1С
ИмяСхемы = "User";

СхемаProto = "
|syntax = ""proto3"";
|
|message User {
|  string id = 1;
|  string name = 2;
|  string phone = 3;
|  int32 age = 4;
|}
|";

Результат = Компонента.СохранитьСхемуProtobuf(
  ИмяСхемы,
  СхемаProto
);

Если Не Результат Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

---

### Преобразование JSON в Protobuf

Метод **ПреобразоватьВФорматProtobuf** преобразует данные из JSON в бинарный формат Protobuf.

```1С
ПреобразоватьВФорматProtobuf(ДанныеJSON, ИмяСхемы);
```

**ДанныеJSON** - Строка. Обязательный. Данные в формате **JSON**:

```json
{
  "id": "1",
  "name": "Ivan",
  "phone": "+79115672342",
  "age": 30
}
```

**ИмяСхемы** - Строка. Обязательный. Имя схемы, которая ранее была сохранена процедурой **СохранитьСхемуProtobuf**.

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

Пример использования метода **ПреобразоватьВФорматProtobuf**:

```1С
ДанныеJSON = "{
|  ""id"": ""1"",
|  ""name"": ""Ivan"",
|  ""phone"": ""+79115672342"",
|  ""age"": 30
|}";

ИмяСхемы = "User";

Результат = Компонента.ПреобразоватьВФорматProtobuf(
  ДанныеJSON,
  ИмяСхемы
);

Если Не Результат Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

**<span style="color: blue">Обратите внимание:</span>**
- JSON должен соответствовать структуре protobuf схемы
- Поддерживаются все базовые типы protobuf: string, int32, int64, uint32, uint64, sint32, sint64, fixed32, fixed64, sfixed32, sfixed64, bool, float, double, bytes
- Поддерживаются вложенные сообщения и repeated поля

---

### Асинхронная отправка Protobuf

Для **асинхронной** отправки сообщения используйте метод **ОтправитьСообщениеProtobuf**.

```1С
ОтправитьСообщениеProtobuf(Топик, Партиция, Ключ, Заголовки);
```

**Топик** - Строка. Обязательный. Имя топика Kafka.

**Партиция** - Число. Необязательный. Если не указано, то по умолчанию запись производится в 0 раздел. Если указано -1, то партиция выбирается автоматически.

**Ключ** - Строка. Необязательный параметр. Ключ сообщения.

**Заголовки** - Строка. Необязательный. Заголовки в формате "ключ1,значение1;ключ2,значение2".

**Возвращает**:
- `0` (MSG_STATUS_NOT_PERSISTED) - сообщение еще не доставлено
- `1` (MSG_STATUS_POSSIBLY_PERSISTED) - сообщение возможно доставлено
- `2` (MSG_STATUS_PERSISTED) - сообщение гарантированно доставлено
- `-1` - ошибка

Пример использования метода **ОтправитьСообщениеProtobuf**:

```1С
Топик = "USER";

Результат = Компонента.ОтправитьСообщениеProtobuf(
  Топик,
  -1,
  "user_1"
);

Если Результат == -1 Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

---

### Синхронная отправка Protobuf

Для **синхронной** отправки используйте метод **ОтправитьСообщениеProtobufСОжиданиемРезультата**.

```1С
УстановитьПараметр("queue.buffering.max.ms", "1");
УстановитьПараметр("socket.blocking.max.ms", "1");
УстановитьПараметр("message.timeout.ms", "5000");

Результат = Компонента.ОтправитьСообщениеProtobufСОжиданиемРезультата(
  Топик,
  Партиция,
  Ключ,
  Заголовки
);

Если Результат <> 2 Тогда  // RD_KAFKA_MSG_STATUS_PERSISTED
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

Список параметров метода идентичен методу **ОтправитьСообщениеProtobuf**.

---

### Сохранение Protobuf в файл

Файл **Protobuf** можно сохранить в файл:

```1С
СохранитьФайлProtobuf(ИмяФайла);
```

**ИмяФайла** - Строка. Обязательный.

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Декодирование Protobuf сообщения

Метод **ДекодироватьСообщениеProtobuf** позволяет декодировать Protobuf сообщение обратно в JSON или получить двоичные данные.

```1С
ДекодироватьСообщениеProtobuf(ДанныеProtobuf, ИмяСхемы, ВозвращатьJSON);
```

**ДанныеProtobuf** - Строка или БинарныеДанные. Обязательный. Protobuf данные для декодирования (например, полученные из Kafka через **ПолучитьДанныеСообщения**).

**ИмяСхемы** - Строка. Обязательный. Имя схемы для декодирования.

**ВозвращатьJSON** - Булево. Необязательный. По умолчанию **Истина**:
- **Истина** - возвращает декодированные данные в формате JSON
- **Ложь** - возвращает исходные двоичные данные

**Возвращает**:
- При **ВозвращатьJSON = Истина**: Строка с JSON
- При **ВозвращатьJSON = Ложь**: БинарныеДанные с исходным Protobuf содержимым
- Пустая строка в случае ошибки. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

#### Пример использования

Пример декодирования Protobuf сообщения, полученного из Kafka:

```1С
// Инициализация и подписка на топик
Компонента.ИнициализироватьПотребителя("localhost:9092");
Компонента.Подписаться("USER");

// Получаем сообщение
Если Компонента.ПолучитьСообщение() Тогда

    // Получаем Protobuf данные из сообщения
    ДанныеProtobuf = Компонента.ПолучитьДанныеСообщения(Истина); // Истина = бинарные данные

    // Декодируем в JSON
    ДанныеJSON = Компонента.ДекодироватьСообщениеProtobuf(
        ДанныеProtobuf,
        "User",      // Имя схемы
        Истина       // Возвращать JSON
    );

    Если ПустаяСтрока(ДанныеJSON) Тогда
        ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
    КонецЕсли;

    Сообщение(ДанныеJSON);

КонецЕсли;
```

Пример декодирования Protobuf файла:

```1С
// Читаем Protobuf файл
ДвоичныеДанные = Новый ДвоичныеДанные("C:\data\user.pb");

// Декодируем в JSON
ДанныеJSON = Компонента.ДекодироватьСообщениеProtobuf(
    ДвоичныеДанные,
    "User",      // Имя схемы
    Истина       // Возвращать JSON
);

Если Не ПустаяСтрока(ДанныеJSON) Тогда
    Сообщение(ДанныеJSON);
Иначе
    ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

---

## Сравнение Protobuf и AVRO

| Характеристика | Protobuf | AVRO |
|----------------|----------|------|
| Схема | .proto файлы | JSON схема |
| Размер | Очень компактный | Компактный |
| Скорость | Очень быстрый | Быстрый |
| Читаемость | Требуется схема | Схема встроена в файл |
| Поддержка языков | Широкая | Хорошая |
| Эволюция схемы | Обратная совместимость | Прямая и обратная совместимость |

**<span style="color: blue">Обратите внимание:</span>**
- Protobuf обычно на 20-30% компактнее AVRO
- Protobuf быстрее AVRO в сериализации/десериализации
- AVRO хранит схему внутри файла, Protobuf требует отдельного хранения схемы
- Используйте Protobuf для высоконагруженных систем с установленными схемами
- Используйте AVRO для систем с частыми изменениями схем и самодокументируемых данных
