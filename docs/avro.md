## Поддержка AVRO

Внешняя компонента может формировать файлы в бинарном формате **AVRO**, который поддерживает передачу данных по схемам, которые записываются в заголовок файла формата **AVRO** при его создании.

### Оглавление

| Метод | Описание |
|-------|----------|
| [СохранитьСхемуAVRO](#формирование-сообщения-в-формате-avro) | Сохранение схемы AVRO |
| [ПреобразоватьВФорматAVRO](#формирование-avro-из-json) | Преобразование JSON в формат AVRO |
| [ОтправитьСообщениеAVRO](#асинхронная-отправка) | Асинхронная отправка AVRO в Kafka |
| [ОтправитьСообщениеAVROСОжиданиемРезультата](#синхронная-отправка) | Синхронная отправка AVRO в Kafka |
| [СохранитьФайлAVRO](#сохранение-данных-в-формате-avro-в-файл) | Сохранение AVRO в файл |
| [ДекодироватьСообщениеAVRO](#декодирование-avro-сообщения) | Декодирование AVRO в JSON или двоичные данные |

---

### Поддерживаемые типы данных

| Тип AVRO | Описание | Представление в JSON/1С |
|----------|----------|------------------------|
| `string` | Строка | `"текст"` |
| `long` | Целое 64-бит | `12345678901234` |
| `int` | Целое 32-бит | `12345` |
| `float` | Дробное одинарной точности | `3.14` |
| `double` | Дробное двойной точности | `3.141592653589793` |
| `boolean` | Логическое | `true` / `false` |
| `null` | Пустое значение | `null` |
| `bytes` | Двоичные данные | Строка с данными |
| `fixed` | Байты фиксированной длины | Строка или UUID |
| `union` | Объединение типов | `["null", "string"]` → `null` или `"текст"` |
| `record` | Вложенная структура | `{...}` (объект) |
| `enum` | Перечисление | `"Symbol"` (строка-символ) |
| `array` | Массив | `[...]` |
| `map` | Словарь строка→значение | `{"key": value}` |

**Логические типы:**
- **UUID** — передаётся как строка `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
- **decimal** — передаётся как строка `"1234.56"` (для типа `bytes` с `logicalType: decimal`)

---

### Формирование сообщения в формате AVRO

Сохранение схемы, которая будет использоваться для **AVRO**.
```1С
СохранитьСхемуAVRO(ИмяСхемыJSON, СхемаJSON);
```

**ИмяСхемыJSON** - Строка. Обязательный. Имя схемы.

**СхемаJSON** - Строка. Обязательный. Схема в формате JSON.

#### Простая схема

```json
{
  "type": "record",
  "name": "User",
  "fields": [
    { "name": "id", "type": "string" },
    { "name": "name", "type": "string" },
    { "name": "age", "type": ["null", "int"] }
  ]
}
```

#### Сложная схема с вложенными структурами

```json
{
  "type": "record",
  "name": "Order",
  "namespace": "com.example",
  "fields": [
    {
      "name": "header",
      "type": {
        "type": "record",
        "name": "Header",
        "fields": [
          { "name": "timestamp", "type": "long" },
          { "name": "source", "type": "string" }
        ]
      }
    },
    {
      "name": "status",
      "type": {
        "type": "enum",
        "name": "Status",
        "symbols": ["Created", "Processing", "Completed", "Cancelled"]
      }
    },
    {
      "name": "items",
      "type": {
        "type": "array",
        "items": {
          "type": "record",
          "name": "Item",
          "fields": [
            { "name": "sku", "type": "string" },
            { "name": "quantity", "type": "int" },
            { "name": "price", "type": "double" }
          ]
        }
      }
    },
    {
      "name": "metadata",
      "type": {
        "type": "map",
        "values": "string"
      }
    },
    { "name": "comment", "type": ["null", "string"], "default": null }
  ]
}
```

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Формирование **AVRO** из JSON

```1С
ПреобразоватьВФорматAVRO(ДанныеJSON, ИмяСхемыJSON);
```

**ДанныеJSON** - Строка. Обязательный. Данные в формате **JSON**.

#### Форматы входных данных

Поддерживаются три формата:

**1. Стандартный формат — один объект (рекомендуется):**
```json
{
  "id": "1",
  "name": "Ivan",
  "age": 25
}
```

**2. Стандартный формат — массив объектов:**
```json
[
  { "id": "1", "name": "Ivan", "age": 25 },
  { "id": "2", "name": "Maria", "age": null },
  { "id": "3", "name": "Peter", "age": 30 }
]
```

**3. Столбцовый формат (для совместимости с предыдущими версиями):**
```json
{
  "id":   ["1", "2", "3"],
  "name": ["Ivan", "Maria", "Peter"],
  "age":  [25, null, 30]
}
```

#### Пример со сложной схемой

Для схемы `Order` из примера выше:

```json
{
  "header": {
    "timestamp": 1704067200000,
    "source": "1C:ERP"
  },
  "status": "Created",
  "items": [
    { "sku": "SKU-001", "quantity": 2, "price": 1599.99 },
    { "sku": "SKU-002", "quantity": 1, "price": 2499.00 }
  ],
  "metadata": {
    "region": "Moscow",
    "priority": "high"
  },
  "comment": "Срочная доставка"
}
```

#### Пример использования в 1С

```1С
// Простой пример
ДанныеJSON = "{
|  ""id"": ""user-001"",
|  ""name"": ""Иван Петров"",
|  ""age"": 30
|}";

Результат = Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "User");

Если Не Результат Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

```1С
// Сложный пример с вложенными структурами
Заказ = Новый Структура;

// Вложенный record
Заголовок = Новый Структура("timestamp, source",
    ТекущаяУниверсальнаяДатаВМиллисекундах(), "1C:ERP");
Заказ.Вставить("header", Заголовок);

// Enum — строка-символ
Заказ.Вставить("status", "Created");

// Array of records
Товары = Новый Массив;
Товары.Добавить(Новый Структура("sku, quantity, price", "SKU-001", 2, 1599.99));
Товары.Добавить(Новый Структура("sku, quantity, price", "SKU-002", 1, 2499.00));
Заказ.Вставить("items", Товары);

// Map
Метаданные = Новый Соответствие;
Метаданные.Вставить("region", "Moscow");
Метаданные.Вставить("priority", "high");
Заказ.Вставить("metadata", Метаданные);

// Union ["null", "string"] — строка или Null
Заказ.Вставить("comment", "Срочная доставка");

// Сериализация в JSON
ЗаписьJSON = Новый ЗаписьJSON;
ЗаписьJSON.УстановитьСтроку();
ЗаписатьJSON(ЗаписьJSON, Заказ);
ДанныеJSON = ЗаписьJSON.Закрыть();

// Преобразование в AVRO
Результат = Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "Order");
```

**ИмяСхемыJSON** - Строка. Обязательный. Имя схемы, которая ранее была сохранена процедурой **СохранитьСхемуAVRO**

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Пример использования UUID

Схема с полем UUID:
```json
{
  "type": "record",
  "name": "Document",
  "fields": [
    {
      "name": "id",
      "type": { "type": "string", "logicalType": "uuid" }
    },
    { "name": "title", "type": "string" },
    {
      "name": "author_id",
      "type": ["null", { "type": "string", "logicalType": "uuid" }]
    }
  ]
}
```

Данные с UUID:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "Документ 1",
  "author_id": "123e4567-e89b-12d3-a456-426614174000"
}
```

---

### Отправка данных в формате AVRO в Kafka

В случае успешного формирования файла **AVRO** данные можно отправить в соответствующий топик в **Kafka** при помощи методов.

### Асинхронная отправка

Для **асинхронной** отправки сообщения необходимо использовать метод **ОтправитьСообщениеAVRO**. Возвращаемое значение аналогично методу **ОтправитьСообщение**.

**Топик** - Строка.

**Партиция** - Число. Если не указано значение, то по умолчанию запись производится в 0 раздел.

**Ключ** - Строка. Необязательный параметр. Ключ сообщения, который может использоваться в темах с уплотнением сообщений по ключу.

**Заголовки** - Строка. Перечень заголовков, состоящих из ключа и значения в следующем формате "ключ1,значение1;ключ2,значение2"

Пример использования метода **ОтправитьСообщениеAVRO**:
```1С
Топик = "USER";

Результат = Компонента.ОтправитьСообщениеAVRO(
  Топик,
  ,
  "key"
);

Если Результат = -1 Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

#### Синхронная отправка

Для **синхронной** отправки необходимо использовать метод **ОтправитьСообщениеAVROСОжиданиемРезультата**, состав параметров и возвращаемое значение аналогичны методу асинхронной отправки **ОтправитьСообщениеAVRO**.

```1c
УстановитьПараметр("queue.buffering.max.ms", "1");
УстановитьПараметр("socket.blocking.max.ms", "1");
УстановитьПараметр("message.timeout.ms", "5000");

Результат = ОтправитьСообщениеAVROСОжиданиемРезультата(Сообщение, Топик, Партиция, Ключ, Заголовки)
Если Результат <> 2 Тогда	// RD_KAFKA_MSG_STATUS_PERSISTED
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

Список параметров метода идентичен методу *ОтправитьСообщениеAVRO*

---

### Сохранение данных в формате AVRO в файл

Файл **AVRO** можно сохранить в файл:

```1c
СохранитьФайлAVRO(ИмяФайла)
```

**ИмяФайла** - Строка. Обязательный.

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Декодирование AVRO сообщения

Метод **ДекодироватьСообщениеAVRO** позволяет декодировать AVRO сообщение обратно в JSON или получить двоичные данные.

```1c
ДекодироватьСообщениеAVRO(ДанныеAVRO, ИмяСхемыJSON, ВозвращатьJSON)
```

**ДанныеAVRO** - Строка или БинарныеДанные. Обязательный. AVRO данные для декодирования (например, полученные из Kafka через **ПолучитьДанныеСообщения**).

**ИмяСхемыJSON** - Строка. Необязательный. Имя схемы для декодирования. Если не указано или пустая строка, используется схема из самого AVRO файла.

**ВозвращатьJSON** - Булево. Необязательный. По умолчанию **Истина**:
- **Истина** - возвращает декодированные данные в формате JSON
- **Ложь** - возвращает исходные двоичные данные

**Возвращает**:
- При **ВозвращатьJSON = Истина**: Строка с JSON
  - Если одна запись: `{...}` — объект
  - Если несколько записей: `[{...}, {...}]` — массив объектов
- При **ВозвращатьJSON = Ложь**: БинарныеДанные с исходным AVRO содержимым
- Пустая строка в случае ошибки. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

#### Пример декодирования простого сообщения

```1С
// Получаем сообщение из Kafka
Если Компонента.ПрочитатьСообщение() Тогда
    // Получаем AVRO данные
    ДанныеAVRO = Компонента.ПолучитьДанныеСообщения(Истина);

    // Декодируем в JSON
    ДанныеJSON = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "User", Истина);

    Если ПустаяСтрока(ДанныеJSON) Тогда
        ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
    КонецЕсли;

    // Парсим JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(ДанныеJSON);
    Данные = ПрочитатьJSON(ЧтениеJSON);

    // Доступ к полям
    Сообщить("ID: " + Данные.id);
    Сообщить("Имя: " + Данные.name);
КонецЕсли;
```

#### Пример декодирования сложного сообщения

```1С
// Декодируем сообщение со сложной схемой
ДанныеJSON = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "Order", Истина);

ЧтениеJSON = Новый ЧтениеJSON;
ЧтениеJSON.УстановитьСтроку(ДанныеJSON);
Заказ = ПрочитатьJSON(ЧтениеJSON);

// Доступ к вложенным данным
Сообщить("Источник: " + Заказ.header.source);
Сообщить("Статус: " + Заказ.status);           // enum как строка
Сообщить("Комментарий: " + Заказ.comment);     // union - строка или Null

// Массив товаров
Для Каждого Товар Из Заказ.items Цикл
    Сообщить(СтрШаблон("  %1 x %2 = %3",
        Товар.sku, Товар.quantity, Товар.price));
КонецЦикла;

// Map метаданных
Сообщить("Регион: " + Заказ.metadata["region"]);
```

**Обратите внимание:**
- Метод автоматически извлекает схему из AVRO файла, если **ИмяСхемыJSON** не указано
- Вложенные record возвращаются как вложенные объекты JSON
- Enum возвращается как строка-символ
- Array возвращается как массив JSON
- Map возвращается как объект JSON
- UUID автоматически преобразуется в строковый формат `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
