## Поддержка AVRO

Внешняя компонента может формировать файлы в бинарном формате **AVRO**, который поддерживает передачу данных по схемам, которые записываются в заголовок файла формата **AVRO** при его создании.

### Оглавление

| Метод | Описание |
|-------|----------|
| [СохранитьСхемуAVRO](#формирование-сообщения-в-формате-avro) | Сохранение схемы AVRO |
| [ПреобразоватьВФорматAVRO](#формирование-avro-из-json) | Преобразование JSON в формат AVRO (OCF, Raw, Confluent Wire Format) |
| [ОтправитьСообщениеAVRO](#асинхронная-отправка) | Асинхронная отправка AVRO в Kafka |
| [ОтправитьСообщениеAVROСОжиданиемРезультата](#синхронная-отправка) | Синхронная отправка AVRO в Kafka |
| [СохранитьФайлAVRO](#сохранение-данных-в-формате-avro-в-файл) | Сохранение AVRO в файл |
| [ДекодироватьСообщениеAVRO](#декодирование-avro-сообщения) | Декодирование AVRO в JSON или raw данные |
| [ПолучитьСхемуAVRO](#получение-схемы-из-avro-файла) | Извлечение схемы из AVRO файла |

---

### Поддерживаемые типы данных

| Тип AVRO | Описание | Представление в JSON/1С |
|----------|----------|------------------------|
| `string` | Строка | `"текст"` |
| `long` | Целое 64-бит | `12345678901234` |
| `int` | Целое 32-бит | `12345` |
| `float` | Дробное одинарной точности | `3.14` |
| `double` | Дробное двойной точности | `3.141592653589793` |
| `boolean` | Логическое | `true` / `false` |
| `null` | Пустое значение | `null` |
| `bytes` | Двоичные данные | Строка с данными |
| `fixed` | Байты фиксированной длины | Строка или UUID |
| `union` | Объединение типов | `["null", "string"]` → `null` или `"текст"` |
| `record` | Вложенная структура | `{...}` (объект) |
| `enum` | Перечисление | `"Symbol"` (строка-символ) |
| `array` | Массив | `[...]` |
| `map` | Словарь строка→значение | `{"key": value}` |

**Логические типы:**
- **UUID** — передаётся как строка `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`
- **decimal** — передаётся как строка `"1234.56"` (для типа `bytes` с `logicalType: decimal`)

---

### Формирование сообщения в формате AVRO

Сохранение схемы, которая будет использоваться для **AVRO**.
```1С
СохранитьСхемуAVRO(ИмяСхемыJSON, СхемаJSON);
```

**ИмяСхемыJSON** - Строка. Обязательный. Имя схемы.

**СхемаJSON** - Строка. Обязательный. Схема в формате JSON.

#### Простая схема

```json
{
  "type": "record",
  "name": "User",
  "fields": [
    { "name": "id", "type": "string" },
    { "name": "name", "type": "string" },
    { "name": "age", "type": ["null", "int"] }
  ]
}
```

#### Сложная схема с вложенными структурами

```json
{
  "type": "record",
  "name": "Order",
  "namespace": "com.example",
  "fields": [
    {
      "name": "header",
      "type": {
        "type": "record",
        "name": "Header",
        "fields": [
          { "name": "timestamp", "type": "long" },
          { "name": "source", "type": "string" }
        ]
      }
    },
    {
      "name": "status",
      "type": {
        "type": "enum",
        "name": "Status",
        "symbols": ["Created", "Processing", "Completed", "Cancelled"]
      }
    },
    {
      "name": "items",
      "type": {
        "type": "array",
        "items": {
          "type": "record",
          "name": "Item",
          "fields": [
            { "name": "sku", "type": "string" },
            { "name": "quantity", "type": "int" },
            { "name": "price", "type": "double" }
          ]
        }
      }
    },
    {
      "name": "metadata",
      "type": {
        "type": "map",
        "values": "string"
      }
    },
    { "name": "comment", "type": ["null", "string"], "default": null }
  ]
}
```

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Формирование **AVRO** из JSON

```1С
ПреобразоватьВФорматAVRO(ДанныеJSON, ИмяСхемыJSON, Формат, ИдСхемы);
```

**ДанныеJSON** - Строка. Обязательный. Данные в формате **JSON**.

**ИмяСхемыJSON** - Строка. Обязательный. Имя схемы, которая ранее была сохранена процедурой **СохранитьСхемуAVRO**.

**Формат** - Строка. Необязательный. Формат выходных данных. По умолчанию — пустая строка (OCF):

| Значение | Описание |
|----------|----------|
| `""` или `"ocf"` | **Avro Object Container Format** — полный контейнер с заголовком, схемой и sync-маркерами. Подходит для сохранения в файл. Формат по умолчанию |
| `"raw"` | **Raw Avro** — чистый бинарный Avro без контейнера. Подходит для отправки в Kafka при интеграции с внешними системами |
| `"confluent"` | **Confluent Wire Format** — magic byte (`0x00`) + 4 байта schema ID (big-endian) + raw Avro binary. Стандартный формат Confluent Platform для работы со Schema Registry |

**ИдСхемы** - Число. Необязательный. Идентификатор схемы в Schema Registry. Используется только при формате `"confluent"`. По умолчанию — 0.

#### Форматы входных данных

Поддерживаются три формата:

**1. Стандартный формат — один объект (рекомендуется):**
```json
{
  "id": "1",
  "name": "Ivan",
  "age": 25
}
```

**2. Стандартный формат — массив объектов:**
```json
[
  { "id": "1", "name": "Ivan", "age": 25 },
  { "id": "2", "name": "Maria", "age": null },
  { "id": "3", "name": "Peter", "age": 30 }
]
```

**3. Столбцовый формат (для совместимости с предыдущими версиями):**
```json
{
  "id":   ["1", "2", "3"],
  "name": ["Ivan", "Maria", "Peter"],
  "age":  [25, null, 30]
}
```

#### Пример со сложной схемой

Для схемы `Order` из примера выше:

```json
{
  "header": {
    "timestamp": 1704067200000,
    "source": "1C:ERP"
  },
  "status": "Created",
  "items": [
    { "sku": "SKU-001", "quantity": 2, "price": 1599.99 },
    { "sku": "SKU-002", "quantity": 1, "price": 2499.00 }
  ],
  "metadata": {
    "region": "Moscow",
    "priority": "high"
  },
  "comment": "Срочная доставка"
}
```

#### Пример использования в 1С

```1С
// Простой пример
ДанныеJSON = "{
|  ""id"": ""user-001"",
|  ""name"": ""Иван Петров"",
|  ""age"": 30
|}";

Результат = Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "User");

Если Не Результат Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

```1С
// Сложный пример с вложенными структурами
Заказ = Новый Структура;

// Вложенный record
Заголовок = Новый Структура("timestamp, source",
    ТекущаяУниверсальнаяДатаВМиллисекундах(), "1C:ERP");
Заказ.Вставить("header", Заголовок);

// Enum — строка-символ
Заказ.Вставить("status", "Created");

// Array of records
Товары = Новый Массив;
Товары.Добавить(Новый Структура("sku, quantity, price", "SKU-001", 2, 1599.99));
Товары.Добавить(Новый Структура("sku, quantity, price", "SKU-002", 1, 2499.00));
Заказ.Вставить("items", Товары);

// Map
Метаданные = Новый Соответствие;
Метаданные.Вставить("region", "Moscow");
Метаданные.Вставить("priority", "high");
Заказ.Вставить("metadata", Метаданные);

// Union ["null", "string"] — строка или Null
Заказ.Вставить("comment", "Срочная доставка");

// Сериализация в JSON
ЗаписьJSON = Новый ЗаписьJSON;
ЗаписьJSON.УстановитьСтроку();
ЗаписатьJSON(ЗаписьJSON, Заказ);
ДанныеJSON = ЗаписьJSON.Закрыть();

// Преобразование в AVRO (OCF — по умолчанию)
Результат = Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "Order");
```

#### Примеры различных форматов

```1С
// OCF формат (по умолчанию) — для сохранения в файл
Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "User");
Компонента.СохранитьФайлAVRO("C:\Data\users.avro");

// Raw Avro — для отправки в Kafka без контейнера
Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "User", "raw");
Компонента.ОтправитьСообщениеAVRO("USER_TOPIC");

// Confluent Wire Format — для совместимости с Confluent Schema Registry
// Сначала получаем ID схемы из Schema Registry
ОтветJSON = Компонента.ЗарегистрироватьСхему(АдресРеестра, "User-value", СхемаJSON);
ЧтениеJSON = Новый ЧтениеJSON;
ЧтениеJSON.УстановитьСтроку(ОтветJSON);
Ответ = ПрочитатьJSON(ЧтениеJSON);
ИдСхемы = Ответ.id;

// Формируем сообщение в Confluent Wire Format
Компонента.ПреобразоватьВФорматAVRO(ДанныеJSON, "User", "confluent", ИдСхемы);
Компонента.ОтправитьСообщениеAVRO("USER_TOPIC");
```

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Пример использования UUID

Схема с полем UUID:
```json
{
  "type": "record",
  "name": "Document",
  "fields": [
    {
      "name": "id",
      "type": { "type": "string", "logicalType": "uuid" }
    },
    { "name": "title", "type": "string" },
    {
      "name": "author_id",
      "type": ["null", { "type": "string", "logicalType": "uuid" }]
    }
  ]
}
```

Данные с UUID:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "Документ 1",
  "author_id": "123e4567-e89b-12d3-a456-426614174000"
}
```

---

### Отправка данных в формате AVRO в Kafka

В случае успешного формирования файла **AVRO** данные можно отправить в соответствующий топик в **Kafka** при помощи методов.

### Асинхронная отправка

Для **асинхронной** отправки сообщения необходимо использовать метод **ОтправитьСообщениеAVRO**. Возвращаемое значение аналогично методу **ОтправитьСообщение**.

**Топик** - Строка.

**Партиция** - Число. Если не указано значение, то по умолчанию запись производится в 0 раздел.

**Ключ** - Строка. Необязательный параметр. Ключ сообщения, который может использоваться в темах с уплотнением сообщений по ключу.

**Заголовки** - Строка. Перечень заголовков, состоящих из ключа и значения в следующем формате "ключ1,значение1;ключ2,значение2"

Пример использования метода **ОтправитьСообщениеAVRO**:
```1С
Топик = "USER";

Результат = Компонента.ОтправитьСообщениеAVRO(
  Топик,
  ,
  "key"
);

Если Результат = -1 Тогда
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

#### Синхронная отправка

Для **синхронной** отправки необходимо использовать метод **ОтправитьСообщениеAVROСОжиданиемРезультата**, состав параметров и возвращаемое значение аналогичны методу асинхронной отправки **ОтправитьСообщениеAVRO**.

```1c
УстановитьПараметр("queue.buffering.max.ms", "1");
УстановитьПараметр("socket.blocking.max.ms", "1");
УстановитьПараметр("message.timeout.ms", "5000");

Результат = ОтправитьСообщениеAVROСОжиданиемРезультата(Сообщение, Топик, Партиция, Ключ, Заголовки)
Если Результат <> 2 Тогда	// RD_KAFKA_MSG_STATUS_PERSISTED
  ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

Список параметров метода идентичен методу *ОтправитьСообщениеAVRO*

---

### Сохранение данных в формате AVRO в файл

Файл **AVRO** можно сохранить в файл:

```1c
СохранитьФайлAVRO(ИмяФайла)
```

**ИмяФайла** - Строка. Обязательный.

**Возвращает** значение типа булево - "Истина", если операция выполнена успешно.
"Ложь", если была ошибка.
Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

---

### Декодирование AVRO сообщения

Метод **ДекодироватьСообщениеAVRO** позволяет декодировать AVRO сообщение в JSON или получить raw Avro данные записей (без контейнера OCF).

```1c
ДекодироватьСообщениеAVRO(ДанныеAVRO, ИмяСхемыJSON, ВозвращатьJSON)
```

**ДанныеAVRO** - Строка или БинарныеДанные. Обязательный. AVRO данные для декодирования (например, полученные из Kafka через **ПолучитьДанныеСообщения** или прочитанные из файла).

**ИмяСхемыJSON** - Строка. Необязательный. Имя схемы для декодирования. Если не указано или пустая строка, используется схема из самого AVRO файла (только для формата OCF).

**ВозвращатьJSON** - Булево. Необязательный. По умолчанию **Истина**:
- **Истина** - возвращает декодированные данные в формате JSON (только данные, без схемы)
- **Ложь** - возвращает raw Avro двоичные данные записей (без заголовка OCF и схемы)

**Возвращает**:
- При **ВозвращатьJSON = Истина**: Строка с JSON
  - Если одна запись: `{...}` — объект
  - Если несколько записей: `[{...}, {...}]` — массив объектов
- При **ВозвращатьJSON = Ложь**: БинарныеДанные с raw Avro содержимым записей (без OCF контейнера)
- Пустая строка в случае ошибки. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

#### Пример декодирования простого сообщения

```1С
// Получаем сообщение из Kafka
Если Компонента.ПрочитатьСообщение() Тогда
    // Получаем AVRO данные
    ДанныеAVRO = Компонента.ПолучитьДанныеСообщения(Истина);

    // Декодируем в JSON
    ДанныеJSON = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "User", Истина);

    Если ПустаяСтрока(ДанныеJSON) Тогда
        ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
    КонецЕсли;

    // Парсим JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(ДанныеJSON);
    Данные = ПрочитатьJSON(ЧтениеJSON);

    // Доступ к полям
    Сообщить("ID: " + Данные.id);
    Сообщить("Имя: " + Данные.name);
КонецЕсли;
```

#### Пример декодирования сложного сообщения

```1С
// Декодируем сообщение со сложной схемой
ДанныеJSON = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "Order", Истина);

ЧтениеJSON = Новый ЧтениеJSON;
ЧтениеJSON.УстановитьСтроку(ДанныеJSON);
Заказ = ПрочитатьJSON(ЧтениеJSON);

// Доступ к вложенным данным
Сообщить("Источник: " + Заказ.header.source);
Сообщить("Статус: " + Заказ.status);           // enum как строка
Сообщить("Комментарий: " + Заказ.comment);     // union - строка или Null

// Массив товаров
Для Каждого Товар Из Заказ.items Цикл
    Сообщить(СтрШаблон("  %1 x %2 = %3",
        Товар.sku, Товар.quantity, Товар.price));
КонецЦикла;

// Map метаданных
Сообщить("Регион: " + Заказ.metadata["region"]);
```

#### Поддерживаемые форматы данных

Метод автоматически определяет формат входных данных:

| Формат | Описание | Требуется схема |
|--------|----------|-----------------|
| **Avro OCF** | Object Container File (начинается с `Obj1`) | Нет (схема в файле) |
| **Confluent Wire Format** | Формат Schema Registry (начинается с `0x00` + schema ID) | Да |
| **Raw Avro** | Сериализованные данные без заголовка | Да |

**Avro OCF** — формат, создаваемый методом `ПреобразоватьВФорматAVRO` с форматом `"ocf"` (по умолчанию). Содержит схему в заголовке файла.

**Confluent Wire Format** — формат, используемый Confluent Schema Registry. Первый байт = `0x00`, затем 4 байта schema ID, затем raw Avro данные. Создаётся методом `ПреобразоватьВФорматAVRO` с форматом `"confluent"`. При декодировании 5-байтовый заголовок автоматически распознаётся и пропускается.

**Raw Avro** — просто сериализованные Avro данные без контейнера. Создаётся методом `ПреобразоватьВФорматAVRO` с форматом `"raw"`. Часто используется при передаче через Kafka.

#### Пример декодирования Raw Avro / Confluent формата

```1С
// Сначала регистрируем схему
СхемаJSON = "{
|  ""type"": ""record"",
|  ""name"": ""User"",
|  ""fields"": [
|    { ""name"": ""id"", ""type"": ""string"" },
|    { ""name"": ""name"", ""type"": ""string"" }
|  ]
|}";
Компонента.СохранитьСхемуAVRO("User", СхемаJSON);

// Получаем сообщение из Kafka (может быть raw Avro или Confluent формат)
Если Компонента.ПрочитатьСообщение() Тогда
    ДанныеAVRO = Компонента.ПолучитьДанныеСообщения(Истина);

    // Для raw/Confluent формата схема ОБЯЗАТЕЛЬНА
    ДанныеJSON = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "User", Истина);

    Если ПустаяСтрока(ДанныеJSON) Тогда
        ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
    КонецЕсли;
КонецЕсли;
```

**Обратите внимание:**
- Для **OCF формата** схема берётся из файла (параметр **ИмяСхемыJSON** необязателен)
- Для **Raw Avro** и **Confluent Wire Format** параметр **ИмяСхемыJSON** **обязателен**
- Вложенные record возвращаются как вложенные объекты JSON
- Enum возвращается как строка-символ
- Array возвращается как массив JSON
- Map возвращается как объект JSON
- Union обрабатывается автоматически (возвращается значение или null)

---

### Получение схемы из AVRO файла

Метод **ПолучитьСхемуAVRO** извлекает схему из AVRO файла в формате OCF и возвращает её в виде JSON строки.

```1c
ПолучитьСхемуAVRO(ДанныеAVRO)
```

**ДанныеAVRO** - БинарныеДанные. Обязательный. AVRO данные в формате OCF (Object Container File).

**Возвращает**: Строка с JSON-представлением схемы. Пустая строка в случае ошибки.

#### Пример использования

```1С
// Читаем AVRO файл
ДанныеAVRO = Новый ДвоичныеДанные("C:\Data\orders.avro");

// Получаем схему
СхемаJSON = Компонента.ПолучитьСхемуAVRO(ДанныеAVRO);

Если ПустаяСтрока(СхемаJSON) Тогда
    ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;

Сообщить("Схема: " + СхемаJSON);

// Можно использовать схему для регистрации
Компонента.СохранитьСхемуAVRO("OrderSchema", СхемаJSON);
```

#### Пример: получение данных и схемы отдельно

```1С
ДанныеAVRO = Новый ДвоичныеДанные("C:\Data\orders.avro");

// Получаем схему отдельно
Схема = Компонента.ПолучитьСхемуAVRO(ДанныеAVRO);

// Получаем данные как JSON (без схемы)
ДанныеJSON = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "", Истина);

// Получаем данные как raw Avro (без OCF контейнера)
ДанныеRaw = Компонента.ДекодироватьСообщениеAVRO(ДанныеAVRO, "", Ложь);
```
