# Публикация сообщений

## Оглавление

| Метод | Описание |
|-------|----------|
| [УстановитьПараметр](#установка-параметров) | Установка параметров продюсера |
| [ПолучитьПараметры](#получение-установленных-параметров) | Получение всех установленных параметров |
| [УстановитьПартишионер](#установка-стратегии-партиционирования) | Установка стратегии партиционирования |
| [УстановитьТаймаутОчисткиПродюсера](#настройка-таймаутов) | Установка таймаута ожидания отправки |
| [ПолучитьМетрикиПродюсера](#метрики-продюсера) | Получение статистики работы продюсера |
| [ИнициализироватьПродюсера](#инициализация-подключения-к-брокерам) | Инициализация подключения к брокерам |
| [ОтправитьСообщение](#асинхронная-отправка) | Асинхронная отправка сообщения |
| [ОтправитьСообщениеСОжиданиемРезультата](#синхронная-отправка) | Синхронная отправка сообщения |
| [ОтправитьПакетСообщений](#пакетная-отправка-сообщений) | Пакетная отправка нескольких сообщений |
| [ОстановитьПродюсера](#остановка-продюсера) | Остановка продюсера |

---

## Последовательность использования методов компоненты и их описание

### Установка параметров

При необходимости можно установить параметры. Доступные параметры для продюсера помечены в колонке "C/P" символами "P" или "*" (см. https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md)

По умолчанию для продюсера можно не устанавливать никаких параметров.

```1c
УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);
```

**ИмяПараметра** - Строка. Имя параметра, согласно колонке *Property* в [данной таблице](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md) 

**ЗначениеПараметра** - Строка. Доступные значения приведены в колонках *Range* и *Default* в [данной таблице](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md)

### Получение установленных параметров

Для получения всех параметров, которые были установлены через метод `УстановитьПараметр`, используется метод:

```1c
ПолучитьПараметры()
```

Метод возвращает строку JSON со списком всех установленных параметров.

Структура:
+ parameters - Массив установленных параметров
  + key - Имя параметра
  + value - Значение параметра

Пример использования:

```1c
Компонента.УстановитьПараметр("group.id", "testGroup");
Компонента.УстановитьПараметр("message.max.bytes", "10485760");
Компонента.УстановитьПараметр("security.protocol", "SASL_SSL");

ПараметрыJSON = Компонента.ПолучитьПараметры();
// Результат:
// {
//     "parameters": [
//         { "key": "group.id", "value": "testGroup" },
//         { "key": "message.max.bytes", "value": "10485760" },
//         { "key": "security.protocol", "value": "SASL_SSL" }
//     ]
// }
```

---

## Установка стратегии партиционирования

Метод позволяет установить стратегию распределения сообщений по партициям топика.

```1c
УстановитьПартишионер(ТипПартишионера)
```

**ТипПартишионера** - Строка. Тип стратегии партиционирования.

Доступные типы:
| Тип | Описание |
|-----|----------|
| consistent | Консистентное хеширование по ключу (одинаковые ключи всегда попадают в одну партицию) |
| consistent_random | (по умолчанию) Как consistent, но для сообщений без ключа выбирается случайная партиция |
| murmur2 | Алгоритм Murmur2, совместимый с Java-клиентом Kafka |
| murmur2_random | Как murmur2, но случайная партиция для сообщений без ключа |
| fnv1a | Алгоритм FNV-1a |
| fnv1a_random | Как fnv1a, но случайная партиция для сообщений без ключа |
| random | Всегда случайная партиция (равномерное распределение) |

Метод возвращает `Истина` при успешной установке, `Ложь` - при ошибке.
В случае ошибки текст можно получить методом `ПолучитьСообщениеОбОшибке()`.

> **Важно:** Метод должен быть вызван **до** вызова `ИнициализироватьПродюсера`.

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Устанавливаем партиционер murmur2 для совместимости с Java-клиентами
Если Компонента.УстановитьПартишионер("murmur2") Тогда
    Сообщить("Партиционер установлен");
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;

// Затем инициализируем продюсера
Компонента.ИнициализироватьПродюсера("localhost:9092");
```

**Когда использовать разные типы партиционеров:**

1. **consistent_random** (по умолчанию) - подходит для большинства случаев. Сообщения с одинаковыми ключами гарантированно попадают в одну партицию.

2. **murmur2** - используйте, если в вашей системе есть Java-консьюмеры и важна совместимость алгоритма хеширования.

3. **random** - используйте для максимально равномерного распределения нагрузки, когда порядок сообщений не важен.

---

## Настройка таймаутов

### УстановитьТаймаутОчисткиПродюсера

Устанавливает таймаут ожидания отправки всех сообщений из внутренней очереди продюсера при вызове `ОстановитьПродюсера`.

```1c
УстановитьТаймаутОчисткиПродюсера(Таймаут)
```

**Таймаут** - Число. Таймаут в миллисекундах. По умолчанию 20000 (20 секунд).

Метод возвращает `Истина` при успешной установке, `Ложь` - при некорректном значении.

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Устанавливаем таймаут очистки 30 секунд
Компонента.УстановитьТаймаутОчисткиПродюсера(30000);

Компонента.ИнициализироватьПродюсера("localhost:9092");

// ... отправка сообщений ...

// При остановке продюсер будет ждать до 30 секунд для отправки всех сообщений
Компонента.ОстановитьПродюсера();
```

> **Примечание:** Увеличьте таймаут, если вы отправляете большие объемы сообщений и хотите гарантировать их доставку при остановке продюсера.

---

## Метрики продюсера

Получение статистики работы продюсера для мониторинга и диагностики.

```1c
ПолучитьМетрикиПродюсера()
```

Метод возвращает строку JSON с метриками.

Структура:
+ messages_produced - Количество отправленных сообщений
+ bytes_produced - Объем отправленных данных в байтах
+ errors_count - Количество ошибок при отправке
+ retries_count - Количество повторных попыток отправки
+ uptime_seconds - Время работы продюсера в секундах

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
Компонента.ИнициализироватьПродюсера("localhost:9092");

// Отправляем несколько сообщений
Для Счетчик = 1 По 100 Цикл
    Компонента.ОтправитьСообщение("Сообщение " + Счетчик, "my-topic");
КонецЦикла;

// Получаем метрики
МетрикиJSON = Компонента.ПолучитьМетрикиПродюсера();

// Парсинг JSON
ЧтениеJSON = Новый ЧтениеJSON;
ЧтениеJSON.УстановитьСтроку(МетрикиJSON);
Метрики = ПрочитатьJSON(ЧтениеJSON);

Сообщить("Отправлено сообщений: " + Метрики["messages_produced"]);
Сообщить("Отправлено байт: " + Метрики["bytes_produced"]);
Сообщить("Ошибок: " + Метрики["errors_count"]);
Сообщить("Повторных попыток: " + Метрики["retries_count"]);
Сообщить("Время работы (сек): " + Метрики["uptime_seconds"]);

Компонента.ОстановитьПродюсера();
```

Пример ответа:

```json
{
    "messages_produced": "100",
    "bytes_produced": "4500",
    "errors_count": "0",
    "retries_count": "2",
    "uptime_seconds": "15.234"
}
```

**Практические применения:**

1. **Мониторинг производительности** - отслеживание скорости отправки сообщений.

2. **Диагностика проблем** - высокое значение errors_count или retries_count указывает на проблемы с брокером или сетью.

3. **Сбор статистики** - интеграция метрик в системы мониторинга (Zabbix, Prometheus, Grafana).

---

## Инициализация подключения к брокерам 

```1c
ИнициализироватьПродюсера(Брокеры)
```

**Брокеры** - Строка. Список брокеров кластера, разделенные запятой. 

Если в кластере несколько брокеров, то достаточно указать одного основного брокера. Брокер содержит все необходимую информацию об других связанных с ним брокерах в кластере.

Метод возвращает значение типа булево, означающее успешность выполнения действия. В случае значения "Ложь" текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.


## Публикация сообщений. Асинхронная и синхронная отправка сообщений

Библиотека librdkafka, на которой основана компонента, по своей природе имеет асинхронную архитектуру взаимодействия с брокерами.

### Асинхронная отправка

Для **асинхронной** отправки сообщения необходимо использовать метод **ОтправитьСообщение**.

> **Важно:** Асинхронный метод помещает сообщение во внутреннюю очередь librdkafka для отправки и **немедленно возвращает управление**. Фактическая доставка происходит в фоновом режиме. Метод возвращает статус помещения в очередь, а **не статус доставки**.

Метод возвращает значение типа целое:
- **0** (RD_KAFKA_MSG_STATUS_NOT_PERSISTED) — сообщение успешно помещено в очередь на отправку. Это **нормальный результат** для асинхронного метода, так как подтверждение от брокера ещё не получено.
- **-1** — произошла ошибка при помещении сообщения в очередь (например, продюсер не инициализирован).

> **Примечание:** Для получения реального статуса доставки (0, 1, 2) используйте синхронный метод **ОтправитьСообщениеСОжиданиемРезультата** или анализируйте файл лога продюсера.

В случае возвращаемого значения -1 текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

```1c
ОтправитьСообщение(Сообщение, Топик, Партиция, Ключ, Заголовки)
```

**Сообщение** - Строка, ДвоичныеДанные Тело сообщения, например json строка.

**Топик** - Строка.

**Партиция** - Число. Если не указано значение, то по умолчанию запись производится в 0 раздел.

**Ключ** - Строка. Необязательный параметр. Ключ сообщения, который может использоваться в темах с уплотнением сообщений по ключу.

**Заголовки** - Строка. Перечень заголовков, состоящих из ключа и значения в следующем формате "ключ1,значение1;ключ2,значение2"

В случае асинхронной отправки - результаты доставки можно получить с помощью следующих архитектурных подходов:
+ При создании экземпляра продюсера, создаем так же экземпляр консьюмера, подписываемся на тему, куда производится отправка. После отправки каждого сообщения - получаем с помощью экземпляра консьюмера сообщение, вычисляем хэш отправленного и полученного сообщения (или же используем ключи сообщений). Сравниваем хэши или ключи - в случае совпадения - считаем сообщение доставленным.
+ Настраиваем считывание из файла лога. Если при отправке был указан key сообщения, в лог будет выведен key и результат доставки. Если key не был указан - в лог будет выведен хэш (md5) сообщения.
    
Порядок полей в логе: Дата время: Хэш или ключ сообщения, Статус доставки:Причина, Размер сообщения в байтах, Топик, Смещение (-1001 если все плохо), Партиция (-1 если все плохо), Брокер (-1 если все плохо).

Примеры строк в логе доставки
    
    2023-09-24 09:59:18.54614692 Key:205f03b5-9c64-4752-9fb4-0b8695789648, Status:Persisted, Details:Success, Size:28, Topic:testTopic, Offset:20553, Partition:0, BrokerID:0
	2023-09-24 10:01:57.958599455 Hash:ed59c8ed6c3209e9e6e434c2d9fbe52a, Status:Persisted, Details:Success, Size:28, Topic:testTopic, Offset:20554, Partition:0, BrokerID:0
	2023-09-24 10:18:32.495522885 Error: Configuration property "socket.blocking.max.ms" value 0 is outside allowed range 1..60000
	2023-09-24 12:56:10.311876162 Hash:dbee3cf28689a286066db820f6a8583e, Status:NotPersisted, Details:Local Message timed out, Size:9546, Topic:testTopic, Offset:-1001, Partition:-1, BrokerID:-1
		
### Синхронная отправка

Для **синхронной** отправки необходимо использовать метод **ОтправитьСообщениеСОжиданиемРезультата**. В отличие от асинхронного метода, он **ожидает подтверждения от брокера** и возвращает реальный статус доставки. Время ожидания — 20 секунд.

Метод возвращает значение типа целое:
- **0** (RD_KAFKA_MSG_STATUS_NOT_PERSISTED) — сообщение не было доставлено или завершилось с ошибкой.
- **1** (RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED) — сообщение было передано брокеру, но подтверждение не получено (возможно доставлено).
- **2** (RD_KAFKA_MSG_STATUS_PERSISTED) — сообщение успешно записано в журнал, получено подтверждение от брокера.
- **-1** — произошла ошибка (продюсер не инициализирован или другая критическая ошибка).

В случае возвращаемых значений -1, 0 и 1 текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

В рамках синхронной отправки рекомендуется устанавливать параметры **queue.buffering.max.ms** и **socket.blocking.max.ms** в самые минимальные значения, чтобы во внутреннем буфере сообщений не происходило накопление данных и сообщения могли отправляться сразу, минуя буфер.

Так же следует обратить внимание на параметр **message.timeout.ms**. Данным параметром мы указываем, сколько времени в мс. мы должны ждать подтверждения от брокеров. Брокеры могут и не отправить подтверждения, если, к примеру, они не доступны. В этом случае, рекомендуется устанавливать данный параметр в диапазоне от 1000 до 20000 мс. В противном случае - недоступности брокеров и включенном логировании в компоненте - в логе продюсера не будет никакой информации об проблеме.

```1c
УстановитьПараметр("queue.buffering.max.ms", "1");
УстановитьПараметр("socket.blocking.max.ms", "1");
УстановитьПараметр("message.timeout.ms", "5000");

РезультатОтправки = ОтправитьСообщениеСОжиданиемРезультата(Сообщение, Топик, Партиция, Ключ, Заголовки)
```

Список параметров метода идентичен методу *ОтправитьСообщение*

---

## Пакетная отправка сообщений

Для отправки нескольких сообщений одной операцией используется метод **ОтправитьПакетСообщений**. Этот метод позволяет эффективно отправлять множество сообщений, минимизируя количество обращений к API компоненты.

```1c
ОтправитьПакетСообщений(МассивСообщенийJSON, Топик)
```

**МассивСообщенийJSON** - Строка. JSON-массив с сообщениями для отправки.

**Топик** - Строка. Имя топика, в который будут отправлены все сообщения.

Метод возвращает целое число - количество успешно отправленных сообщений. В случае ошибки парсинга JSON или неинициализированного продюсера возвращается -1.

### Формат JSON

Каждое сообщение в массиве должно быть объектом со следующими полями:

- **message** (обязательное) - Строка. Тело сообщения.
- **key** (необязательное) - Строка. Ключ сообщения.
- **partition** (необязательное) - Число. Номер партиции. Если не указан, используется -1 (автоматический выбор).
- **headers** (необязательное) - Строка. Заголовки в формате "ключ1,значение1;ключ2,значение2".

Пример JSON:

```json
[
    {
        "message": "Сообщение 1",
        "key": "order-001",
        "partition": 0,
        "headers": "type,order;priority,high"
    },
    {
        "message": "Сообщение 2",
        "key": "order-002"
    },
    {
        "message": "Сообщение 3"
    }
]
```

### Пример использования

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Инициализируем продюсера
Если НЕ Компонента.ИнициализироватьПродюсера("localhost:9092") Тогда
    ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;

// Формируем массив сообщений
МассивСообщений = Новый Массив;

Сообщение1 = Новый Структура;
Сообщение1.Вставить("message", "Первое сообщение");
Сообщение1.Вставить("key", "key-001");
Сообщение1.Вставить("partition", 0);
МассивСообщений.Добавить(Сообщение1);

Сообщение2 = Новый Структура;
Сообщение2.Вставить("message", "Второе сообщение");
Сообщение2.Вставить("key", "key-002");
МассивСообщений.Добавить(Сообщение2);

Сообщение3 = Новый Структура;
Сообщение3.Вставить("message", "Третье сообщение");
Сообщение3.Вставить("headers", "type,notification;priority,low");
МассивСообщений.Добавить(Сообщение3);

// Конвертируем в JSON
ЗаписьJSON = Новый ЗаписьJSON;
ЗаписьJSON.УстановитьСтроку();
ЗаписатьJSON(ЗаписьJSON, МассивСообщений);
МассивСообщенийJSON = ЗаписьJSON.Закрыть();

// Отправляем пакет сообщений
КоличествоОтправленных = Компонента.ОтправитьПакетСообщений(МассивСообщенийJSON, "my-topic");

Если КоличествоОтправленных = -1 Тогда
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
Иначе
    Сообщить("Успешно отправлено сообщений: " + КоличествоОтправленных);
КонецЕсли;

// Останавливаем продюсера
Компонента.ОстановитьПродюсера();
```

### Особенности работы

1. **Обработка ошибок**: Если одно из сообщений не удалось отправить (например, из-за переполнения очереди), метод автоматически повторит попытку отправки после небольшой задержки.

2. **Производительность**: При пакетной отправке метод использует внутреннюю буферизацию librdkafka, что повышает производительность по сравнению с последовательной отправкой отдельных сообщений.

3. **Возвращаемое значение**: Метод возвращает количество успешно отправленных сообщений. Если это число меньше общего количества сообщений в массиве, следует проверить лог продюсера для выявления проблем.

4. **Логирование**: Все операции пакетной отправки логируются в файл продюсера (если настроено логирование). В логе можно увидеть количество обработанных сообщений и детали ошибок.

### Когда использовать пакетную отправку

Пакетная отправка рекомендуется в следующих случаях:

- Необходимо отправить большое количество сообщений за короткое время
- Важна производительность и пропускная способность
- Сообщения имеют схожую структуру и отправляются в один топик
- Требуется минимизировать количество обращений к API компоненты

Для отправки одиночных сообщений или когда требуется немедленное подтверждение каждого сообщения, используйте методы **ОтправитьСообщение** или **ОтправитьСообщениеСОжиданиемРезультата**.

---

## Остановка продюсера

После того как была произведена отправка всех необходимых сообщений и больше нет необходимости в использовании инстанса продюсера - необходимо обязательно производить остановку продюсера. 

Метод возвращает значение типа булево, означающее успешность выполнения действия. В случае значения "Ложь" текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

```1c
ОстановитьПродюсера()
```

## Пример асинхронной отправки

```1c
Если ТипЗнч(Данные) <> Тип("Массив") Тогда
    Сообщения = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Данные);
Иначе
    Сообщения = Данные;
КонецЕсли;

Если ТипЗнч(Параметры) = Тип("Соответствие") ИЛИ (ТипЗнч(Параметры) = Тип("Структура")) Тогда
    Для каждого Параметр Из Параметры Цикл
        Компонента.УстановитьПараметр(Строка(Параметр.Ключ), Строка(Параметр.Значение));
    КонецЦикла;
КонецЕсли;

// инициализируем подключение к брокеру
// достаточно указать одного брокера из кластера, либо есть возможность перечислить брокеров через символ запятая
РезультатИнициализации = Компонента.ИнициализироватьПродюсера(Брокеры);

Если РезультатИнициализации Тогда

    Для каждого СообщениеВКафку Из Сообщения Цикл
        // Parametr1 - Тело сообщения (строка)
        // Parametr2 - Топик (строка)
        // Parametr3 - Номер партиции, по умолчанию = -1 (число)
        // Parametr4 - Произвольный ключ, идентифицирующий сообщение, например GUID (строка)
        // Parametr5 - Заголовки (строка), "ключ1,значение1;ключ2,значение2"
        РезультатОтправки = Компонента.ОтправитьСообщение(СообщениеВКафку, Топик,, Ключ, Заголовки);
        // Для асинхронной отправки проверяем только на ошибку (-1)
        // Значение 0 означает успешное помещение в очередь
        Если РезультатОтправки = -1 Тогда
            ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;
    КонецЦикла;

    Компонента.ОстановитьПродюсера();
    Компонента = Неопределено;
Иначе
    ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```

## Пример синхронной отправки с проверкой доставки

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Рекомендуемые параметры для синхронной отправки
Компонента.УстановитьПараметр("queue.buffering.max.ms", "1");
Компонента.УстановитьПараметр("message.timeout.ms", "5000");

РезультатИнициализации = Компонента.ИнициализироватьПродюсера("localhost:9092");

Если РезультатИнициализации Тогда

    Для каждого СообщениеВКафку Из Сообщения Цикл
        // Синхронная отправка с ожиданием подтверждения от брокера
        РезультатОтправки = Компонента.ОтправитьСообщениеСОжиданиемРезультата(СообщениеВКафку, Топик,, Ключ, Заголовки);

        Если РезультатОтправки = 2 Тогда  // RD_KAFKA_MSG_STATUS_PERSISTED
            // Сообщение успешно доставлено и подтверждено брокером
        ИначеЕсли РезультатОтправки = 1 Тогда  // RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED
            // Сообщение возможно доставлено, но подтверждение не получено
            Предупреждение("Сообщение возможно доставлено: " + Компонента.ПолучитьСообщениеОбОшибке());
        Иначе  // 0 или -1
            ВызватьИсключение "Ошибка доставки: " + Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;
    КонецЦикла;

    Компонента.ОстановитьПродюсера();
Иначе
    ВызватьИсключение Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;
```
