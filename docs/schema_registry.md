# Schema Registry API

Компонента поддерживает интеграцию с Confluent Schema Registry для централизованного управления схемами данных.

## Оглавление

| Метод | Описание |
|-------|----------|
| [ЗарегистрироватьСхему](#зарегистрироватьсхему) | Регистрация новой схемы в реестре |
| [ПолучитьСхемуПоИД](#получитьсхемупоид) | Получение схемы по её идентификатору |
| [ПолучитьПоследнююСхему](#получитьпоследнююсхему) | Получение последней версии схемы для субъекта |
| [ПолучитьВерсииСхемы](#получитьверсиисхемы) | Получение списка всех версий схемы |
| [УдалитьСхему](#удалитьсхему) | Удаление версии схемы |

---

## Что такое Schema Registry?

Schema Registry - это централизованное хранилище схем данных (Avro, JSON Schema, Protobuf), которое:

- Обеспечивает совместимость схем между продюсерами и консьюмерами
- Хранит историю версий схем
- Позволяет проверять совместимость новых схем с существующими
- Упрощает сериализацию/десериализацию сообщений

## Методы

### ЗарегистрироватьСхему

Регистрирует новую схему в Schema Registry для указанного субъекта.

```1c
ЗарегистрироватьСхему(URLРеестра, Субъект, Схема)
```

**URLРеестра** - Строка. URL адрес Schema Registry (например, "http://localhost:8081").

**Субъект** - Строка. Имя субъекта (обычно это имя топика с суффиксом `-value` или `-key`).

**Схема** - Строка. JSON-строка со схемой данных.

Метод возвращает строку JSON с информацией о зарегистрированной схеме.

Структура ответа:
+ id - Уникальный идентификатор схемы в реестре

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Определяем Avro-схему
СхемаJSON = "{
    |""type"": ""record"",
    |""name"": ""User"",
    |""namespace"": ""com.example"",
    |""fields"": [
    |    {""name"": ""id"", ""type"": ""int""},
    |    {""name"": ""name"", ""type"": ""string""},
    |    {""name"": ""email"", ""type"": [""null"", ""string""], ""default"": null}
    |]
    |}";

// Регистрируем схему для субъекта "users-value"
РезультатJSON = Компонента.ЗарегистрироватьСхему("http://localhost:8081", "users-value", СхемаJSON);

Если ПустаяСтрока(РезультатJSON) Тогда
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
Иначе
    // Парсинг JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(РезультатJSON);
    Результат = ПрочитатьJSON(ЧтениеJSON);

    Сообщить("Схема зарегистрирована с ID: " + Результат["id"]);
КонецЕсли;
```

Пример ответа:

```json
{
    "id": "1"
}
```

> **Примечание:** Если схема уже существует (идентична существующей), возвращается её текущий ID без создания дубликата.

---

### ПолучитьСхемуПоИД

Получает схему по её уникальному идентификатору.

```1c
ПолучитьСхемуПоИД(URLРеестра, IDСхемы)
```

**URLРеестра** - Строка. URL адрес Schema Registry.

**IDСхемы** - Число. Уникальный идентификатор схемы.

Метод возвращает строку JSON со схемой.

Структура ответа:
+ schema - JSON-строка с определением схемы

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Получаем схему с ID = 1
РезультатJSON = Компонента.ПолучитьСхемуПоИД("http://localhost:8081", 1);

Если ПустаяСтрока(РезультатJSON) Тогда
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
Иначе
    // Парсинг JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(РезультатJSON);
    Результат = ПрочитатьJSON(ЧтениеJSON);

    Сообщить("Схема: " + Результат["schema"]);
КонецЕсли;
```

Пример ответа:

```json
{
    "schema": "{\"type\":\"record\",\"name\":\"User\",\"namespace\":\"com.example\",\"fields\":[{\"name\":\"id\",\"type\":\"int\"},{\"name\":\"name\",\"type\":\"string\"}]}"
}
```

---

### ПолучитьПоследнююСхему

Получает последнюю (актуальную) версию схемы для указанного субъекта.

```1c
ПолучитьПоследнююСхему(URLРеестра, Субъект)
```

**URLРеестра** - Строка. URL адрес Schema Registry.

**Субъект** - Строка. Имя субъекта.

Метод возвращает строку JSON с информацией о схеме.

Структура ответа:
+ subject - Имя субъекта
+ version - Номер версии
+ id - ID схемы
+ schema - JSON-строка с определением схемы

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Получаем последнюю версию схемы для субъекта "users-value"
РезультатJSON = Компонента.ПолучитьПоследнююСхему("http://localhost:8081", "users-value");

Если ПустаяСтрока(РезультатJSON) Тогда
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
Иначе
    // Парсинг JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(РезультатJSON);
    Результат = ПрочитатьJSON(ЧтениеJSON);

    Сообщить("Субъект: " + Результат["subject"]);
    Сообщить("Версия: " + Результат["version"]);
    Сообщить("ID: " + Результат["id"]);
    Сообщить("Схема: " + Результат["schema"]);
КонецЕсли;
```

Пример ответа:

```json
{
    "subject": "users-value",
    "version": "3",
    "id": "5",
    "schema": "{\"type\":\"record\",\"name\":\"User\",\"namespace\":\"com.example\",\"fields\":[{\"name\":\"id\",\"type\":\"int\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"email\",\"type\":[\"null\",\"string\"],\"default\":null}]}"
}
```

---

### ПолучитьВерсииСхемы

Получает список всех версий схемы для указанного субъекта.

```1c
ПолучитьВерсииСхемы(URLРеестра, Субъект)
```

**URLРеестра** - Строка. URL адрес Schema Registry.

**Субъект** - Строка. Имя субъекта.

Метод возвращает строку JSON с массивом номеров версий.

Структура ответа:
+ versions - Массив номеров версий

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Получаем список версий схемы для субъекта "users-value"
РезультатJSON = Компонента.ПолучитьВерсииСхемы("http://localhost:8081", "users-value");

Если ПустаяСтрока(РезультатJSON) Тогда
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
Иначе
    // Парсинг JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(РезультатJSON);
    Результат = ПрочитатьJSON(ЧтениеJSON);

    Сообщить("Доступные версии:");
    Для Каждого Версия Из Результат["versions"] Цикл
        Сообщить("  - Версия " + Версия);
    КонецЦикла;
КонецЕсли;
```

Пример ответа:

```json
{
    "versions": ["1", "2", "3"]
}
```

---

### УдалитьСхему

Удаляет указанную версию схемы для субъекта.

```1c
УдалитьСхему(URLРеестра, Субъект, Версия)
```

**URLРеестра** - Строка. URL адрес Schema Registry.

**Субъект** - Строка. Имя субъекта.

**Версия** - Строка. Номер версии для удаления. Можно использовать "latest" для удаления последней версии.

Метод возвращает `Истина` при успешном удалении, `Ложь` - при ошибке.
В случае ошибки текст можно получить методом `ПолучитьСообщениеОбОшибке()`.

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Удаляем версию 2 схемы для субъекта "users-value"
Если Компонента.УдалитьСхему("http://localhost:8081", "users-value", "2") Тогда
    Сообщить("Версия 2 схемы удалена");
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;

// Удаляем последнюю версию
Если Компонента.УдалитьСхему("http://localhost:8081", "users-value", "latest") Тогда
    Сообщить("Последняя версия схемы удалена");
КонецЕсли;
```

> **Внимание:** Удаление схемы является необратимой операцией. Убедитесь, что схема не используется продюсерами или консьюмерами.

---

## Практические примеры

### Полный цикл работы со схемой

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

URLРеестра = "http://localhost:8081";
Субъект = "orders-value";

// 1. Создаем схему для заказов
СхемаЗаказа = "{
    |""type"": ""record"",
    |""name"": ""Order"",
    |""namespace"": ""com.example.orders"",
    |""fields"": [
    |    {""name"": ""order_id"", ""type"": ""string""},
    |    {""name"": ""customer_id"", ""type"": ""string""},
    |    {""name"": ""amount"", ""type"": ""double""},
    |    {""name"": ""status"", ""type"": ""string""},
    |    {""name"": ""created_at"", ""type"": ""long"", ""logicalType"": ""timestamp-millis""}
    |]
    |}";

// 2. Регистрируем схему
РезультатJSON = Компонента.ЗарегистрироватьСхему(URLРеестра, Субъект, СхемаЗаказа);
Если Не ПустаяСтрока(РезультатJSON) Тогда
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(РезультатJSON);
    Результат = ПрочитатьJSON(ЧтениеJSON);
    IDСхемы = Результат["id"];
    Сообщить("Схема зарегистрирована, ID: " + IDСхемы);
КонецЕсли;

// 3. Получаем схему обратно по ID
СхемаJSON = Компонента.ПолучитьСхемуПоИД(URLРеестра, Число(IDСхемы));
Сообщить("Схема из реестра: " + СхемаJSON);

// 4. Проверяем доступные версии
ВерсииJSON = Компонента.ПолучитьВерсииСхемы(URLРеестра, Субъект);
Сообщить("Доступные версии: " + ВерсииJSON);

// 5. Получаем последнюю версию
ПоследняяJSON = Компонента.ПолучитьПоследнююСхему(URLРеестра, Субъект);
Сообщить("Последняя версия: " + ПоследняяJSON);
```

### Интеграция с AVRO

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

URLРеестра = "http://localhost:8081";
Топик = "users";
Субъект = Топик + "-value";

// 1. Получаем последнюю схему из реестра
СхемаJSON = Компонента.ПолучитьПоследнююСхему(URLРеестра, Субъект);

Если ПустаяСтрока(СхемаJSON) Тогда
    ВызватьИсключение "Схема не найдена: " + Компонента.ПолучитьСообщениеОбОшибке();
КонецЕсли;

// 2. Парсим ответ и извлекаем схему
ЧтениеJSON = Новый ЧтениеJSON;
ЧтениеJSON.УстановитьСтроку(СхемаJSON);
Результат = ПрочитатьJSON(ЧтениеJSON);
АвроСхема = Результат["schema"];

// 3. Регистрируем схему в компоненте для работы с AVRO
Компонента.УстановитьАвроСхему("user_schema", АвроСхема);

// 4. Теперь можно конвертировать данные в AVRO формат
ДанныеJSON = "{""id"": 123, ""name"": ""Иван Иванов"", ""email"": ""ivan@example.com""}";
Если Компонента.КонвертироватьВАвроФормат(ДанныеJSON, "user_schema") Тогда
    // Данные сконвертированы, можно отправлять
    Компонента.ИнициализироватьПродюсера("localhost:9092");
    Компонента.ОтправитьАвроСообщение(Топик, 0, "user-123", "");
    Компонента.ОстановитьПродюсера();
КонецЕсли;
```

---

## Настройка Schema Registry

### Docker Compose пример

```yaml
version: '3'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    ports:
      - "9092:9092"

  schema-registry:
    image: confluentinc/cp-schema-registry:latest
    depends_on:
      - kafka
    environment:
      SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS: kafka:9092
      SCHEMA_REGISTRY_HOST_NAME: schema-registry
      SCHEMA_REGISTRY_LISTENERS: http://0.0.0.0:8081
    ports:
      - "8081:8081"
```

### Проверка работы Schema Registry

```bash
# Проверка доступности
curl http://localhost:8081/

# Список субъектов
curl http://localhost:8081/subjects

# Получение схемы
curl http://localhost:8081/subjects/my-topic-value/versions/latest
```

---

## Коды ошибок

| Код | Описание |
|-----|----------|
| 40401 | Субъект не найден |
| 40402 | Версия не найдена |
| 40403 | Схема не найдена |
| 42201 | Некорректная схема |
| 42202 | Некорректная версия |
| 409 | Конфликт совместимости |

При возникновении ошибки используйте метод `ПолучитьСообщениеОбОшибке()` для получения детальной информации.
