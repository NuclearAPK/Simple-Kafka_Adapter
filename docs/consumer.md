# Чтение сообщений

Отличительной особенностью релиза >= 1.1.0 является возможность чтения сообщений из нескольких топиков в рамках одного консьюмера. Такой подход позволяет сэкономить память, но немного снижает параллельность, если после чтения сообщения выполняется бизнес логика обработки сообщения. Рекомендуется использовать именно такой подход.

Возможность создавать консьюмера на каждый топик также остается. В этом случае повышается параллельность работы, но есть нюансы с логированием информации от консьюмеров в файлы (пишется информация от последнего подключенного консьюмера).

## Оглавление

| Метод | Описание |
|-------|----------|
| [УстановитьПараметр](#установка-параметра-groupid) | Установка параметров консьюмера |
| [ПолучитьСмещенияГруппыКонсьюмеров](#получение-текущих-позиций-смещений-консьюмера) | Получение текущих смещений группы |
| [УстановитьПозициюЧтения](#установка-позиции-чтения) | Установка позиции чтения для топика |
| [УстановитьПозицииЧтения](#установка-позиции-чтения) | Установка позиций чтения (JSON) |
| [ПерейтиКНачалу](#управление-позицией-чтения) | Переход к началу партиции |
| [ПерейтиККонцу](#управление-позицией-чтения) | Переход к концу партиции |
| [ПерейтиКВременнойМетке](#управление-позицией-чтения) | Переход к указанной временной метке |
| [ИнициализироватьКонсьюмера](#инициализация-консьюмера) | Инициализация подключения к брокеру |
| [Подписаться](#подписка-на-топики) | Подписка на топики |
| [УстановитьТаймаутОжидания](#установка-таймаута-ожидания-сообщений) | Установка таймаута ожидания |
| [ПрочитатьСообщение](#получение-сообщений) | Чтение сообщения из очереди |
| [ПолучитьДанныеСообщения](#получение-сообщений) | Получение данных сообщения |
| [ПолучитьКлючСообщения](#получение-сообщений) | Получение ключа сообщения |
| [ПолучитьЗаголовкиСообщения](#получение-сообщений) | Получение заголовков сообщения |
| [ПолучитьТопикСообщения](#получение-сообщений) | Получение топика сообщения |
| [ПолучитьИдентификаторБрокераСообщения](#получение-сообщений) | Получение ID брокера |
| [ПолучитьВременнуюМеткуСообщения](#получение-сообщений) | Получение timestamp сообщения |
| [ПолучитьРазделСообщения](#получение-сообщений) | Получение партиции сообщения |
| [ПолучитьСмещениеСообщения](#получение-сообщений) | Получение offset сообщения |
| [Слушать](#получение-сообщений) | Чтение сообщения (устаревший) |
| [ЗафиксироватьСмещение](#фиксация-смещения-после-чтения) | Фиксация смещения |
| [НазначитьПартиции](#явное-назначение-партиций) | Явное назначение партиций (manual assignment) |
| [ПолучитьНазначение](#явное-назначение-партиций) | Получение текущего назначения партиций |
| [ОтменитьНазначение](#явное-назначение-партиций) | Отмена назначения партиций |
| [ОстановитьКонсьюмера](#завершение-работы-консьюмера) | Остановка консьюмера |

---

## Последовательность использования методов компоненты и их описание

### Установка параметра group.id

Минимальный параметр, который требуется установить, для того чтобы начать получать сообщения - это **group.id**

```1c
УстановитьПараметр("group.id", ИмяВашейГруппы);
```

**ИмяВашейГруппы** - Строка.

### Получение текущих позиций смещений консьюмера 

Если необходимо получить текущее смещение в разрезе топиков и их разделов для консьюмера, указанного в параметре **group.id**, то используется метод:

```1c
ПолучитьСмещенияГруппыКонсьюмеров(Брокер, ВременнаяМетка, Таймаут);
```

**Брокер** - Строка. Брокер, например 192.168.0.139:9092 или список брокеров, разделенных запятой. Порт можно не указывать, так же, если используется кластер, то нет необходимости указывать список всех брокеров, достаточно указать основного брокера. Брокер хранит информацию об других, связанных брокерах кластера.

**ВременнаяМетка** Строка. Если параметр не задан - из брокера получается последняя зафиксированная информация о смещениях, если значение указано, то смещения, зарегистрированные на данную отметку времени. По умолчанию = "". Важный момент: временная метка на брокере хранится с учетом миллисекунд, и в utc. Код получения временной метки может быть следующим:

```
Час = 3600;
ТД = Число(ТекущаяУниверсальнаяДата() - Дата("19700101")) - Час;
TimeStampДатыСмещения = Формат(ТД*1000, "ЧГ=");
```

**Таймаут** - Число. Указывается продолжительность ожидания получения ответа от брокера, если по истечении указанного интервала не будет получен ответ - таймаут увеличивается на 1000 ms и повторяется попытка получения данных от брокера. По умолчанию = 5000 ms

Данный метод **не является обязательным**. Метод возвращает значения JSON строкой следующего формата:

```json
{
    "metadata": [
        {
            "topic": "testTopicParts",
            "partition": "0",
            "offset": "48"
        }
	]
}
```

**metadata** - Массив, содержит структуру {topic, partition, offset}. 

**topic** - Строка. Имя топика.

**partition** - Число. Номер раздела.

**offset** - Число. Зафиксированное смещение.

### Установка позиции чтения

В большинстве случаев отправной точкой - откуда начинать считывать сообщения консьюмеру - управлять не нужно.
По умолчанию консьюмер начнет потреблять сообщения с последнего зафиксированного смещения. Если для темы + раздела и группы нет ранее зафиксированного смещения, он вернется к свойству конфигурации темы **auto.offset.reset**, которое установлено по умолчанию в **latest**.
Таким образом, консьюмер начинает потреблять сообщения с конца раздела (будут потребляться только новые сообщения).

Но бывают ситуации, в которых необходимо заново перечитать сообщения с определенной позиции. Для этого в компоненте реализован следующий метод:

```1c
УстановитьПозициюЧтения(Топик, Смещение, Партиция);
```

**Топик** - Строка. Имя топика.

**Смещение** - Число. Позиция, с которой нужно начать чтение.

**Партиция** - Число. Номер партиции, по умолчанию = 0.

Данный метод **не является обязательным**. Метод является устаревшем и используется для совместимости кода, относительно предыдущих версий компоненты. 

**! Рекомедуется использовать метод УстановитьПозицииЧтения**

Метод возвращает значение Истина - операция выполнена успешно, Ложь - в противном случае. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**

```1c
УстановитьПозицииЧтения(СтрокаJSON);
```

**СтрокаJSON** - Строка. В структуре JSON указывается информация в следующем формате

```json
{
  "metadata": [
    {
      "topic": "testTopicParts",
      "partition": 0,
      "offset": 41
    }
  ]
}
```

**metadata** - Массив, содержит структуру {topic, partition, offset}. Консьюмер, может быть подписан на разные партиции одного топика или даже на разные топики и разные партиции таких топиков.

**topic** - Строка. Имя топика.

**partition** - Число. Номер раздела.

**offset** - Число. Позиция, с которой нужно начать чтение.

Данный метод **не является обязательным**. 

Метод возвращает значение Истина - операция выполнена успешно, Ложь - в противном случае. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**
Используя данный метод, можно получать значения смещений в разрезе топиков и их разделов, т.к. один консьюмер может быть подписан на разные топики и разные партиции внутри таких топиков.

### Управление позицией чтения

Помимо установки конкретной позиции (offset), консьюмер может переходить к специальным позициям в партициях.

#### ПерейтиКНачалу

```1c
ПерейтиКНачалу(ИмяТопика, Партиция)
```

Перемещает позицию чтения консьюмера к началу указанной партиции.

**ИмяТопика** - Строка. Имя топика.

**Партиция** - Число. Номер партиции.

Метод возвращает `Истина` при успехе, `Ложь` - при ошибке.
В случае ошибки текст можно получить методом `ПолучитьСообщениеОбОшибке()`.

> **Важно:** Для использования этого метода необходим инициализированный консьюмер (`ИнициализироватьКонсьюмера`).

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

Компонента.УстановитьПараметр("group.id", "my-group");
Компонента.ИнициализироватьКонсьюмера("localhost:9092");
Компонента.Подписаться("my-topic");

// Переходим к началу партиции 0
Если Компонента.ПерейтиКНачалу("my-topic", 0) Тогда
    Сообщить("Позиция установлена на начало партиции");

    // Теперь можно читать сообщения с самого начала
    Пока Компонента.ПрочитатьСообщение() Цикл
        Данные = Компонента.ПолучитьДанныеСообщения(Ложь);
        // Обработка данных...
    КонецЦикла;
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;
```

#### ПерейтиККонцу

```1c
ПерейтиККонцу(ИмяТопика, Партиция)
```

Перемещает позицию чтения консьюмера к концу указанной партиции (читать только новые сообщения).

**ИмяТопика** - Строка. Имя топика.

**Партиция** - Число. Номер партиции.

Метод возвращает `Истина` при успехе, `Ложь` - при ошибке.
В случае ошибки текст можно получить методом `ПолучитьСообщениеОбОшибке()`.

> **Важно:** Для использования этого метода необходим инициализированный консьюмер (`ИнициализироватьКонсьюмера`).

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

Компонента.УстановитьПараметр("group.id", "my-group");
Компонента.ИнициализироватьКонсьюмера("localhost:9092");
Компонента.Подписаться("my-topic");

// Переходим к концу партиции 0 (пропускаем все старые сообщения)
Если Компонента.ПерейтиККонцу("my-topic", 0) Тогда
    Сообщить("Позиция установлена на конец партиции, читаем только новые сообщения");

    Пока Компонента.ПрочитатьСообщение() Цикл
        Данные = Компонента.ПолучитьДанныеСообщения(Ложь);
        // Обработка только новых сообщений...
    КонецЦикла;
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;
```

#### ПерейтиКВременнойМетке

```1c
ПерейтиКВременнойМетке(ИмяТопика, Партиция, ВременнаяМетка)
```

Перемещает позицию чтения консьюмера к первому сообщению с указанной или более поздней временной меткой.

**ИмяТопика** - Строка. Имя топика.

**Партиция** - Число. Номер партиции.

**ВременнаяМетка** - Число. Unix timestamp в миллисекундах.

Метод возвращает `Истина` при успехе, `Ложь` - при ошибке.
В случае ошибки текст можно получить методом `ПолучитьСообщениеОбОшибке()`.

> **Важно:** Для использования этого метода необходим инициализированный консьюмер (`ИнициализироватьКонсьюмера`).

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

Компонента.УстановитьПараметр("group.id", "my-group");
Компонента.ИнициализироватьКонсьюмера("localhost:9092");
Компонента.Подписаться("my-topic");

// Вычисляем timestamp для даты (например, 1 января 2024, 00:00:00 UTC)
ДатаНачала = Дата(2024, 1, 1, 0, 0, 0);
ВременнаяМетка = (ДатаНачала - Дата(1970, 1, 1)) * 1000; // конвертируем в миллисекунды

// Переходим к сообщениям с указанной даты
Если Компонента.ПерейтиКВременнойМетке("my-topic", 0, ВременнаяМетка) Тогда
    Сообщить("Позиция установлена на указанную дату");

    // Читаем сообщения с указанной даты
    Пока Компонента.ПрочитатьСообщение() Цикл
        Данные = Компонента.ПолучитьДанныеСообщения(Ложь);
        Метка = Компонента.ПолучитьВременнуюМеткуСообщения();
        // Обработка данных...
    КонецЦикла;
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;
```

> **Примечание:**
> - Метод ищет первое сообщение с временной меткой >= указанной
> - Если такое сообщение не найдено, возвращается ошибка
> - Временные метки сообщений устанавливаются продюсером при отправке

---

### Инициализация консьюмера

```1c
ИнициализироватьКонсьюмера(Брокер)
```

**Брокер** - Строка. Брокер, например 192.168.0.139:9092 или список брокеров, разделенных запятой. Порт можно не указывать, так же, если используется кластер, то нет необходимости указывать список всех брокеров, достаточно указать основного брокера. Брокер хранит информацию об других, связанных брокерах кластера.

Метод возвращает значение Истина - если инициализация успешно проведена, Ложь - в противном случае. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

Метод является обязательным.

### Подписка на топики

```1c
Подписаться(Топики)
```

**Топики** - Строка. Список топиков, разделенных запятой

Метод возвращает значение Истина - если удалось подписаться на топики, Ложь - в противном случае. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

Метод является обязательным.

### Установка таймаута ожидания сообщений

Процесс получения сообщений - это по сути бесконечный цикл, внутри которого происходит проверка - а есть ли новые сообщения? Для того чтобы снизить нагрузку на процессор, используется таймаут ожидания, в рамках которого основной поток приложения блокируется на указанное время в ms.

```1c
УстановитьТаймаутОжидания(Таймаут)
```

**Таймаут** - Число. Указывается продолжительность блокировки основного потока приложения в ms. 

Данный метод не является обязательным, в этом случае таймаут будет составлять 500 ms.

Метод возвращает значение Истина - операция выполнена успешно, Ложь - в противном случае. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

Рекомендуется подбирать данный параметр исходя из архитектуры вашего решения и требований к скорости получения сообщений. 

### Получение сообщений

С релиза 1.4.0 появилась возможность использовать новые методы, с помощью которых можно отдельно получать метаданные сообщения, такие как ключ, заголоки и.т.д, а так же тело самого сообщения в виде двоичных данных (как оно существует в источнике) или же строки UTF-8. Смотри [пример](./examples/modern_consumer.md)

```1c
ПрочитатьСообщение()
```

Метод возвращает значение типа булево: 
 + Истина - Было получено очередное сообщение из очереди
 + Ложь - В очереди нет сообщений

Если по результату вернулось значение **Истина**, можно вызывать следующие нижеперечисленные методы:

```1c
ПолучитьДанныеСообщения(ВозвращатьДвоичныеДаннные)
```

**ВозвращатьДвоичныеДаннные** - Булево. Истина - будут возвращены двоичные данные сообщения. Ложь - будет возвращена строка UTF-8. Значение по умолчанию *Ложь*

```1c
ПолучитьКлючСообщения()
```

Метод возвращает строку - ключ сообщения (*key*)

```1c
ПолучитьЗаголовкиСообщения()
```

Метод возвращает JSON строку, которая содержит массив заголовков, каждый заголовок состоит из ключа и значения (key, value)

```1c
ПолучитьТопикСообщения()
```
Метод возвращает топик, из которого было прочитано сообщение (*topic*).

```1c
ПолучитьИдентификаторБрокераСообщения()
```

Метод возвращает идентификатор брокера, из которого было прочитано сообщение (*broker_id*).

```1c
ПолучитьВременнуюМеткуСообщения()
```
Метод возвращает число, unix timestamp в ms. Фактическое время записи сообщения в топик и указанный раздел.

```1c
ПолучитьРазделСообщения()
```
Метод возвращает число. Номер партиции, из которой было прочитано сообщение (*partition*).

```1c
ПолучитьСмещениеСообщения()
```

Метод возвращает число. Текущее смещение сообщения (*offset*).

Данные методы были добавлены с целью повысить отказоустойчивость работы компоненты и дать возможность не получать данные, которые не нужны. 

Кроме использования новых методов - можно использовать старый подход используя метод **Слушать**

```1c
Слушать()
```

Метод возвращает по одному сообщению из буффера прочитанных сообщений. В случае возникновения ошибки возвращает пустую строку. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.


Сообщение - строка JSON.
Структура:

+ key - Произвольный ключ сообщения, указанный консьюмером при отправке. Если ключ не был указан - данное свойство не будет добавлено в структуру сообщения
+ headers - Массив заголовков, указанных при отправке. Если заголовки отсутствуют, то данное свойство не будет добавлено в структуру сообщения
+ partition - Номер раздела, из которого произведено чтение
+ offset - Смещение (позиция сообщения в разделе)
+ message - Тело сообщения
+ topic - Топик, из которого было прочитано сообщение
+ timestamp - Unix timestamp в ms. Фактическое время записи сообщения в топик и указанный раздел.
+ broker_id - Идентификатор брокера, из которого было получено сообщение. Данное значение можно использовать для анализа работы кластера.

Пример сообщения:

```json
{
    "key": "a4fc050c-a355-4001-a216-d284aa8f7764",
    "partition": "0",
    "offset": "6576732",
    "message": "{\n  \"id\": \"99999\",\n  \"sum\": \"28827.24\",\n  \"Date\": \"05.10.2023 13:32:39\",\n  \"type\": \"monthly\",\n  \"GUID_Loan\": \"90e2df35-430f-11ed-9ec9-005056130ba6\",\n  \"Method\": \"NewPayment\"\n}\u0006",
    "topic": "testTopic",
    "timestamp": "1696758629706",
    "headers": [
        {
            "key": "level",
            "value": "high"
        },
        {
            "key": "buffer",
            "value": "1024"
        },
        {
            "key": "trusted",
            "value": "true"
        }
    ]
}

```
Метод является обязательным.

### Фиксация смещения после чтения

[Пример кода](./examples/auto_commit_off.md)

В большинстве случаев использовать ручное смещение нет смысла. Информация о прочитанных сообщениях - позиции - фиксируется брокером автоматически. За это отвечают следующие настройки

**enable.auto.commit** = true

**auto.commit.interval.ms** = 5000

В тривиальных сценариях, когда мы прочитали сообщение и сложили его, к примеру, в регистр сведений для дальнейшей обработки - можно оставить автоматическую фиксацию, которая используется по умолчанию. Но в случаях, когда после чтения необходимо выполнить определенную бизнес логику - желательно фиксировать смещения вручную.
При таком подходе, необходимо указать следующую комбинацию параметров

**enable.auto.commit** = false

**enable.auto.offset.store** = false

**enable.partition.eof** = false

```1c
ЗафиксироватьСмещение(Топик, Смещение, Партиция)
```

**Топик** - Строка. 

**Смещение** - Число. Значение смещения прочитанного сообщения + 1

**Партиция** - Число. Номер раздела.

Метод возвращает значение Истина - операция выполнена успешно, Ложь - в противном случае. Текст ошибки можно получить функцией **ПолучитьСообщениеОбОшибке**.

Метод не является обязательным.

### Явное назначение партиций

В Kafka существует два способа работы с партициями для консьюмера:

1. **Автоматическое назначение (Subscribe)** - брокер автоматически распределяет партиции между консьюмерами группы. При использовании метода `Подписаться()`, Kafka автоматически управляет назначением партиций и выполняет ребалансировку при изменении группы консьюмеров.

2. **Ручное назначение (Assign)** - вы явно указываете, какие партиции должен читать консьюмер. Это полезно когда:
   - Нужен полный контроль над тем, какие партиции читает консьюмер
   - Требуется обработка специфичных партиций
   - Необходимо избежать автоматической ребалансировки
   - Консьюмер работает вне группы консьюмеров

> **Важно:** Методы `Подписаться()` и `НазначитьПартиции()` взаимоисключающие. Если используется явное назначение, нельзя одновременно использовать подписку.

#### НазначитьПартиции

```1c
НазначитьПартиции(JSONПартиции)
```

Явно назначает консьюмеру конкретные партиции для чтения.

**JSONПартиции** - Строка. JSON-массив с описанием партиций для назначения.

Структура JSON:
```json
[
    {
        "topic": "my-topic",
        "partition": 0,
        "offset": 100
    },
    {
        "topic": "my-topic",
        "partition": 1,
        "offset": 0
    }
]
```

Каждый элемент массива содержит:
- **topic** - имя топика
- **partition** - номер партиции
- **offset** - начальная позиция чтения (необязательно). Если не указано, используется текущее сохраненное смещение или значение из `auto.offset.reset`

Метод возвращает `Истина` при успехе, `Ложь` - при ошибке.
Текст ошибки можно получить методом `ПолучитьСообщениеОбОшибке()`.

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Опционально: установка параметров
Компонента.УстановитьПараметр("group.id", "my-group");
Компонента.ИнициализироватьКонсьюмера("localhost:9092");

// Назначаем консьюмеру партиции 0 и 2 топика "my-topic"
JSONПартиции = "[
    |{""topic"": ""my-topic"", ""partition"": 0, ""offset"": 100},
    |{""topic"": ""my-topic"", ""partition"": 2, ""offset"": 0}
    |]";

Если Компонента.НазначитьПартиции(JSONПартиции) Тогда
    Сообщить("Партиции успешно назначены");

    // Теперь можно читать сообщения только из назначенных партиций
    Пока Компонента.ПрочитатьСообщение() Цикл
        Данные = Компонента.ПолучитьДанныеСообщения(Ложь);
        Партиция = Компонента.ПолучитьРазделСообщения();
        Сообщить("Получено сообщение из партиции: " + Партиция);
    КонецЦикла;
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;

Компонента.ОстановитьКонсьюмера();
```

#### ПолучитьНазначение

```1c
ПолучитьНазначение()
```

Возвращает текущее назначение партиций для консьюмера в формате JSON.

Метод возвращает JSON-строку с информацией о назначенных партициях. При ошибке возвращается пустая строка.

Структура возвращаемого JSON:
```json
{
    "assignment": [
        {
            "topic": "my-topic",
            "partition": "0",
            "offset": "150"
        },
        {
            "topic": "my-topic",
            "partition": "2",
            "offset": "75"
        }
    ]
}
```

Каждый элемент массива содержит:
- **topic** - имя топика
- **partition** - номер партиции
- **offset** - текущая позиция чтения

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

Компонента.УстановитьПараметр("group.id", "my-group");
Компонента.ИнициализироватьКонсьюмера("localhost:9092");

// Назначаем партиции
JSONПартиции = "[{""topic"": ""my-topic"", ""partition"": 0}]";
Компонента.НазначитьПартиции(JSONПартиции);

// Получаем информацию о назначенных партициях
НазначениеJSON = Компонента.ПолучитьНазначение();

Если НЕ ПустаяСтрока(НазначениеJSON) Тогда
    // Парсинг JSON
    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(НазначениеJSON);
    Назначение = ПрочитатьJSON(ЧтениеJSON);

    Для Каждого Партиция Из Назначение["assignment"] Цикл
        Сообщить("Топик: " + Партиция["topic"] +
                 ", Партиция: " + Партиция["partition"] +
                 ", Offset: " + Партиция["offset"]);
    КонецЦикла;
Иначе
    Сообщить("Партиции не назначены");
КонецЕсли;

Компонента.ОстановитьКонсьюмера();
```

#### ОтменитьНазначение

```1c
ОтменитьНазначение()
```

Отменяет все назначенные партиции для консьюмера.

Метод возвращает `Истина` при успехе, `Ложь` - при ошибке.
Текст ошибки можно получить методом `ПолучитьСообщениеОбОшибке()`.

> **Примечание:** После отмены назначения консьюмер перестает читать сообщения. Для возобновления чтения необходимо либо назначить новые партиции методом `НазначитьПартиции()`, либо использовать подписку методом `Подписаться()`.

Пример использования:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

Компонента.УстановитьПараметр("group.id", "my-group");
Компонента.ИнициализироватьКонсьюмера("localhost:9092");

// Назначаем партиции
JSONПартиции = "[{""topic"": ""my-topic"", ""partition"": 0}]";
Компонента.НазначитьПартиции(JSONПартиции);

// Читаем сообщения
Счетчик = 0;
Пока Компонента.ПрочитатьСообщение() И Счетчик < 10 Цикл
    Данные = Компонента.ПолучитьДанныеСообщения(Ложь);
    Счетчик = Счетчик + 1;
КонецЦикла;

// Отменяем назначение партиций
Если Компонента.ОтменитьНазначение() Тогда
    Сообщить("Назначение партиций отменено");
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;

Компонента.ОстановитьКонсьюмера();
```

**Практические сценарии использования явного назначения:**

1. **Обработка конкретных партиций** - когда нужно обработать данные только из определенных партиций, например, при миграции или восстановлении данных.

2. **Параллельная обработка без групп** - можно запустить несколько независимых консьюмеров, каждый для своих партиций, без использования consumer groups.

3. **Тестирование** - удобно для тестирования обработки данных из конкретных партиций.

4. **Обработка исторических данных** - можно начать чтение с определенного offset для переобработки старых сообщений.

Пример параллельной обработки разных партиций:

```1c
// Консьюмер 1 - обрабатывает партиции 0 и 1
Компонента1 = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
Компонента1.УстановитьПараметр("group.id", "worker-1");
Компонента1.ИнициализироватьКонсьюмера("localhost:9092");
Компонента1.НазначитьПартиции("[
    |{""topic"": ""my-topic"", ""partition"": 0},
    |{""topic"": ""my-topic"", ""partition"": 1}
    |]");

// Консьюмер 2 - обрабатывает партиции 2 и 3
Компонента2 = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
Компонента2.УстановитьПараметр("group.id", "worker-2");
Компонента2.ИнициализироватьКонсьюмера("localhost:9092");
Компонента2.НазначитьПартиции("[
    |{""topic"": ""my-topic"", ""partition"": 2},
    |{""topic"": ""my-topic"", ""partition"": 3}
    |]");

// Теперь оба консьюмера независимо обрабатывают свои партиции
```

### Завершение работы консьюмера 

```1c
ОстановитьКонсьюмера()
```

Метод строго **обязательный**. 

## Пример кода

```1c
	РазрешеноСлушать = ПроверитьЗначениеНастройки();

	Попытка
		Компонента = Новый(СтрШаблон("AddIn.%1.simpleKafka1C", "Integration"));   
	Исключение
		Подключено = ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаSimpleKafka", "Integration", ТипВнешнейКомпоненты.Native, ТипПодключенияВнешнейКомпоненты.Изолированно);
		Если Подключено Тогда
			Компонента = Новый(СтрШаблон("AddIn.%1.simpleKafka1C", "Integration"));  	
		КонецЕсли;
	КонецПопытки;
	
	Если Компонента = Неопределено Тогда
		Возврат;	
	КонецЕсли;
	
	Для каждого Параметр_ Из Параметры Цикл
		Компонента.УстановитьПараметр(Строка(Параметр_.Ключ), Строка(Параметр_.Значение));	
	КонецЦикла;   	
	
	Компонента.КаталогЛогов = ПолучитьКаталогЛогов();
	Компонента.ИнициализироватьКонсьюмера(Брокер); 
	
	Результат = Компонента.Подписаться(Топики);

	Если Не Результат Тогда  
		ТекстОшибки = СтрШаблон("Не удалось инициализировать консьюмера для топиков: %1", Топики);  
		ЗаписьЖурналаРегистрации("Интеграция Kafka. Consumer", УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
		Возврат;
	КонецЕсли;  

	// установка таймаута для ожидания сообщений
	Компонента.УстановитьТаймаутОжидания(Таймаут);		               
		
	Пока РазрешеноСлушать Цикл
		
		РазрешеноСлушать = ПроверитьЗначениеНастройки();

		Если Не РазрешеноСлушать Тогда
			Прервать;	
		КонецЕсли;			      
		
		Сообщение = Компонента.Слушать(); 
		Если НЕ ЗначениеЗаполнено(Сообщение) Тогда                 	
			ОписаниеОшибки = Компонента.ПолучитьСообщениеОбОшибке();                                                         
			Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
				Сообщить(ОписаниеОшибки)
				Компонента = Неопределено;
				Возврат;
			КонецЕсли;
		КонецЕсли;
				
		КлючСообщения = ПолучитьХешКлючСообщения(Сообщение);
		Если Не СообщениеПрочитано(КлючСообщения) Тогда	     
			ЗаписатьСообщениеВОчередьОбработки(); // здесь пишем в РС, к примеру	
		КонецЕсли;

	КонецЦикла;  
	
	Компонента.ОстановитьКонсьюмера();	
	Компонента = Неопределено;
```
