# Транзакции (Exactly-Once семантика)

Компонента поддерживает транзакционную отправку сообщений в Kafka с гарантией **Exactly-Once** (ровно один раз). Это означает, что каждое сообщение будет обработано ровно один раз, даже при сбоях.

## Оглавление

| Метод | Описание |
|-------|----------|
| [ИнициализироватьТранзакционногоПродюсера](#инициализация-транзакционного-продюсера) | Инициализация транзакционного продюсера |
| [НачатьТранзакцию](#начать-транзакцию) | Начало новой транзакции |
| [ЗафиксироватьТранзакцию](#зафиксировать-транзакцию) | Фиксация транзакции |
| [ОтменитьТранзакцию](#отменить-транзакцию) | Откат транзакции |
| [ОтправитьОфсетыВТранзакцию](#отправить-офсеты-в-транзакцию) | Сохранение офсетов консьюмера в транзакцию |

---

## Что такое Exactly-Once семантика

**Exactly-Once** — это гарантия того, что:
- Каждое сообщение записывается в Kafka ровно один раз (нет дубликатов)
- Все сообщения в транзакции записываются атомарно: либо все, либо ни одного
- При сбоях и перезапусках продюсера незавершенные транзакции автоматически откатываются
- Консьюмеры с `isolation.level=read_committed` видят только зафиксированные сообщения

## Когда использовать транзакции

✅ **Используйте транзакции когда:**
- Критичны дубликаты сообщений (финансовые операции, платежи, заказы)
- Нужна атомарная отправка связанных сообщений
- Реализуете паттерн Read-Process-Write (чтение → обработка → запись)
- Требуется строгая гарантия доставки

❌ **Не используйте транзакции для:**
- Высоконагруженных некритичных данных (логи, метрики)
- Когда производительность важнее гарантий
- Простых сценариев без связанных операций

> **Примечание:** Транзакции снижают пропускную способность на 20-30% из-за дополнительных служебных записей.

---

## Методы компоненты

### Инициализация транзакционного продюсера

```1c
ИнициализироватьТранзакционногоПродюсера(Брокеры, ИдентификаторТранзакции)
```

**Брокеры** - Строка. Список брокеров кластера, разделенные запятой (например, "localhost:9092").

**ИдентификаторТранзакции** - Строка. Уникальный идентификатор транзакционного продюсера.

> **Важно!**
> - `ИдентификаторТранзакции` должен быть уникальным для каждого экземпляра продюсера
> - При перезапуске используйте тот же идентификатор — Kafka автоматически завершит незавершенные транзакции
> - Не создавайте несколько продюсеров с одинаковым идентификатором одновременно

Метод возвращает `Истина` при успешной инициализации, `Ложь` при ошибке.
В случае ошибки текст можно получить методом `ПолучитьСообщениеОбОшибке()`.

Пример:

```1c
Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

// Опционально: установка параметров
Компонента.УстановитьПараметр("acks", "all"); // Обязательно для транзакций
Компонента.УстановитьПараметр("max.in.flight.requests.per.connection", "5");

// Инициализация транзакционного продюсера
Если Компонента.ИнициализироватьТранзакционногоПродюсера("localhost:9092", "my-app-producer-1") Тогда
    Сообщить("Транзакционный продюсер успешно инициализирован");
Иначе
    Сообщить("Ошибка: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;
```

---

### Начать транзакцию

```1c
НачатьТранзакцию()
```

Начинает новую транзакцию. После вызова этого метода все отправленные сообщения будут частью транзакции и станут видимыми только после вызова `ЗафиксироватьТранзакцию()`.

Метод возвращает `Истина` при успехе, `Ложь` при ошибке.

Пример:

```1c
Если Компонента.НачатьТранзакцию() Тогда
    // Транзакция начата, можно отправлять сообщения
Иначе
    Сообщить("Ошибка начала транзакции: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;
```

---

### Зафиксировать транзакцию

```1c
ЗафиксироватьТранзакцию()
```

Фиксирует текущую транзакцию. После успешного вызова все сообщения транзакции становятся видимыми для консьюмеров с `isolation.level=read_committed`.

Таймаут операции: 30 секунд.

Метод возвращает `Истина` при успехе, `Ложь` при ошибке.

Пример:

```1c
Если Компонента.ЗафиксироватьТранзакцию() Тогда
    // Транзакция успешно зафиксирована
Иначе
    Сообщить("Ошибка фиксации транзакции: " + Компонента.ПолучитьСообщениеОбОшибке());
КонецЕсли;
```

---

### Отменить транзакцию

```1c
ОтменитьТранзакцию()
```

Откатывает текущую транзакцию. Все сообщения, отправленные в рамках транзакции, будут отменены и никогда не станут видимыми для консьюмеров.

Таймаут операции: 30 секунд.

Метод возвращает `Истина` при успехе, `Ложь` при ошибке.

Пример:

```1c
Попытка
    Компонента.НачатьТранзакцию();

    // Отправка сообщений
    РезультатОтправки = Компонента.ОтправитьСообщение(Данные, "my-topic", , "", "");

    Если РезультатОтправки < 0 Тогда
        ВызватьИсключение "Ошибка отправки";
    КонецЕсли;

    Компонента.ЗафиксироватьТранзакцию();
Исключение
    // При ошибке откатываем транзакцию
    Компонента.ОтменитьТранзакцию();
    ВызватьИсключение;
КонецПопытки;
```

---

### Отправить офсеты в транзакцию

```1c
ОтправитьОфсетыВТранзакцию(ОфсетыJSON, ИдентификаторГруппыКонсьюмеров)
```

Фиксирует офсеты консьюмера в контексте текущей транзакции. Используется в паттерне **Read-Process-Write** для обработки сообщений с гарантией exactly-once.

> **Важно:**
> - Для использования этого метода необходим инициализированный консьюмер (через `ИнициализироватьКонсьюмера`)
> - Метод выполняет синхронную фиксацию офсетов через `commitSync`
> - Офсеты фиксируются в рамках группы консьюмера, указанной при инициализации
> - Вызывайте этот метод **после** отправки сообщений, но **до** `ЗафиксироватьТранзакцию`

**ОфсетыJSON** - Строка. JSON с офсетами для сохранения. Формат:

```json
{
  "offsets": [
    {
      "topic": "input-topic",
      "partition": 0,
      "offset": 150
    },
    {
      "topic": "input-topic",
      "partition": 1,
      "offset": 200
    }
  ]
}
```

**ИдентификаторГруппыКонсьюмеров** - Строка. `group.id` консьюмера, для которого сохраняются офсеты.

> **Важно:** Указывайте офсет **следующего** сообщения для чтения (текущий офсет + 1).

Метод возвращает `Истина` при успехе, `Ложь` при ошибке.

Пример:

```1c
// Прочитали сообщение с offset=149
Офсет = 149;

// Формируем JSON для сохранения offset=150 (следующий для чтения)
ОфсетыJSON = СтрШаблон(
    "{""offsets"": [{""topic"": ""input-topic"", ""partition"": 0, ""offset"": %1}]}",
    Офсет + 1
);

// Сохраняем офсет в транзакцию
Компонента.ОтправитьОфсетыВТранзакцию(ОфсетыJSON, "my-consumer-group");
```

---

## Настройка консьюмера для транзакций

Для чтения транзакционных сообщений консьюмер должен быть настроен соответствующим образом:

```1c
// ОБЯЗАТЕЛЬНЫЕ параметры для консьюмера
Компонента.УстановитьПараметр("isolation.level", "read_committed"); // Читать только зафиксированные сообщения
Компонента.УстановитьПараметр("enable.auto.commit", "false"); // Отключить автоматическую фиксацию офсетов
Компонента.УстановитьПараметр("enable.auto.offset.store", "false"); // Отключить автоматическое сохранение офсетов
Компонента.УстановитьПараметр("group.id", "my-consumer-group");

Компонента.ИнициализироватьКонсьюмера("localhost:9092");
Компонента.Подписаться("input-topic");
```

---

## Жизненный цикл транзакции

```
1. ИнициализироватьТранзакционногоПродюсера(brokers, txn_id)
   ↓
2. НачатьТранзакцию()
   ↓
3. ОтправитьСообщение(msg1, topic1, ...)  ← сообщения помечаются как uncommitted
   ОтправитьСообщение(msg2, topic2, ...)
   ...
   ↓
4. (опционально) ОтправитьОфсетыВТранзакцию(offsets, group_id)
   ↓
5. ЗафиксироватьТранзакцию()  ← сообщения становятся видимыми

   ИЛИ

   ОтменитьТранзакцию()  ← сообщения отменяются
```

---

## Сценарии использования

Подробные примеры см. в [документации с примерами](./examples/transactions_examples.md):

1. **Атомарная отправка нескольких сообщений** — все или ничего
2. **Read-Process-Write** — чтение, обработка, запись с exactly-once
3. **Batch processing** — обработка пакетов сообщений

---

## Обработка ошибок

### Сценарий 1: Продюсер упал во время транзакции

```
1. Продюсер начал транзакцию (transactional.id = "prod-1")
2. Отправил несколько сообщений
3. УПАЛ до commit
4. При перезапуске с тем же transactional.id = "prod-1"
5. Kafka автоматически откатывает незавершенную транзакцию
6. Можно начинать новую транзакцию
```

### Сценарий 2: Ошибка во время commit

```1c
Попытка
    Компонента.НачатьТранзакцию();

    // Отправка сообщений
    Для Каждого Сообщение Из МассивСообщений Цикл
        РезультатОтправки = Компонента.ОтправитьСообщение(Сообщение, "topic", , "", "");

        Если РезультатОтправки < 0 Тогда
            ВызватьИсключение "Ошибка отправки сообщения";
        КонецЕсли;
    КонецЦикла;

    // Пытаемся зафиксировать
    Если НЕ Компонента.ЗафиксироватьТранзакцию() Тогда
        ВызватьИсключение "Ошибка фиксации: " + Компонента.ПолучитьСообщениеОбОшибке();
    КонецЕсли;

Исключение
    // Откатываем транзакцию при любой ошибке
    Компонента.ОтменитьТранзакцию();

    // Логируем или обрабатываем ошибку
    ЗаписьЖурналаРегистрации("Транзакции Kafka",
        УровеньЖурналаРегистрации.Ошибка,
        ,
        ,
        ОписаниеОшибки());
КонецПопытки;
```

---

## Важные параметры

### Для транзакционного продюсера:

```1c
// Автоматически устанавливается компонентой:
// - transactional.id (передается в ИнициализироватьТранзакционногоПродюсера)
// - enable.idempotence = true

// Рекомендуется установить вручную:
Компонента.УстановитьПараметр("acks", "all"); // Ждать подтверждения от всех реплик
Компонента.УстановитьПараметр("max.in.flight.requests.per.connection", "5"); // <= 5 для транзакций
Компонента.УстановитьПараметр("transaction.timeout.ms", "60000"); // Таймаут транзакции (по умолчанию 60 сек)
```

### Для консьюмера (Read-Process-Write):

```1c
// ОБЯЗАТЕЛЬНО:
Компонента.УстановитьПараметр("isolation.level", "read_committed");
Компонента.УстановитьПараметр("enable.auto.commit", "false");
Компонента.УстановитьПараметр("enable.auto.offset.store", "false");
```

---

## Производительность

**Влияние на производительность:**
- Транзакции снижают throughput на ~20-30%
- Дополнительные записи в служебные топики (`__transaction_state`)
- Задержка на координацию с брокером

**Рекомендации:**
- Группируйте сообщения в одну транзакцию, когда это возможно
- Не создавайте транзакцию для каждого сообщения в высоконагруженных системах
- Используйте транзакции только там, где критичны дубликаты

---

## Требования к Kafka

- Минимальная версия Kafka: **0.11.0+**
- Рекомендуемая версия: **2.5.0+**
- На брокере должна быть включена поддержка транзакций (включена по умолчанию)

## Особенности реализации

**Метод `ОтправитьОфсетыВТранзакцию`:**

Текущая реализация использует синхронную фиксацию офсетов (`commitSync`) вместо нативного транзакционного API `send_offsets_to_transaction`. Это обеспечивает:

✅ **Совместимость** со всеми версиями librdkafka
✅ **Надежность** — офсеты фиксируются синхронно
✅ **Простоту** использования

⚠️ **Ограничение:** Фиксация офсетов и отправка сообщений не являются полностью атомарными операциями в рамках одной транзакции Kafka. Однако, при корректном использовании паттерна (фиксация офсетов перед commit транзакции) обеспечивается семантика exactly-once на уровне приложения.

Для получения полной атомарности на уровне протокола Kafka потребуется обновление librdkafka и использование нативного `send_offsets_to_transaction` API (планируется в будущих версиях компоненты).

---

## Дополнительные материалы

- [Примеры использования транзакций](./examples/transactions_examples.md)
- [Документация по продюсеру](./producer.md)
- [Документация по консьюмеру](./consumer.md)
- [Kafka Transactions (официальная документация)](https://kafka.apache.org/documentation/#semantics)
