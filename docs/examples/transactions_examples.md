# Примеры использования транзакций

Эта документация содержит практические примеры использования транзакций в компоненте Simple Kafka для различных сценариев.

## Оглавление

1. [Сценарий 1: Атомарная отправка нескольких сообщений](#сценарий-1-атомарная-отправка-нескольких-сообщений)
2. [Сценарий 2: Read-Process-Write (Exactly-Once обработка)](#сценарий-2-read-process-write-exactly-once-обработка)
3. [Сценарий 3: Пакетная обработка сообщений](#сценарий-3-пакетная-обработка-сообщений)
4. [Сценарий 4: Обработка ошибок и откат](#сценарий-4-обработка-ошибок-и-откат)
5. [Сценарий 5: Интеграция с базой данных](#сценарий-5-интеграция-с-базой-данных)

---

## Сценарий 1: Атомарная отправка нескольких сообщений

**Задача:** Отправить несколько связанных сообщений, которые должны быть записаны вместе или не записаны вообще.

**Пример:** Создание заказа, которое требует записи в 3 топика (заказы, платежи, отгрузки).

```1c
Процедура ОтправитьСвязанныеСообщения(ЗаказДанные)

    Попытка
        Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

        // Настройка параметров
        Компонента.УстановитьПараметр("acks", "all");

        // Инициализация транзакционного продюсера
        Если НЕ Компонента.ИнициализироватьТранзакционногоПродюсера("localhost:9092", "orders-producer-1") Тогда
            ВызватьИсключение "Ошибка инициализации: " + Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;

        // Начинаем транзакцию
        Если НЕ Компонента.НачатьТранзакцию() Тогда
            ВызватьИсключение "Ошибка начала транзакции: " + Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;

        // Формируем сообщения
        ЗаказJSON = ПолучитьJSON(ЗаказДанные.Заказ);
        ПлатежJSON = ПолучитьJSON(ЗаказДанные.Платеж);
        ОтгрузкаJSON = ПолучитьJSON(ЗаказДанные.Отгрузка);

        // Отправляем все 3 сообщения
        РезультатЗаказ = Компонента.ОтправитьСообщение(ЗаказJSON, "orders", , ЗаказДанные.ЗаказID, "");
        РезультатПлатеж = Компонента.ОтправитьСообщение(ПлатежJSON, "payments", , ЗаказДанные.ПлатежID, "");
        РезультатОтгрузка = Компонента.ОтправитьСообщение(ОтгрузкаJSON, "shipments", , ЗаказДанные.ОтгрузкаID, "");

        // Проверяем результаты
        Если РезультатЗаказ < 0 ИЛИ РезультатПлатеж < 0 ИЛИ РезультатОтгрузка < 0 Тогда
            ВызватьИсключение "Ошибка отправки сообщений: " + Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;

        // Фиксируем транзакцию - либо все 3 сообщения будут записаны, либо ни одного
        Если НЕ Компонента.ЗафиксироватьТранзакцию() Тогда
            ВызватьИсключение "Ошибка фиксации транзакции: " + Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;

        Сообщить("Все сообщения успешно отправлены атомарно");

    Исключение
        // При любой ошибке откатываем транзакцию
        Попытка
            Компонента.ОтменитьТранзакцию();
        Исключение
            // Логируем ошибку отката
        КонецПопытки;

        ЗаписьЖурналаРегистрации("Транзакции Kafka",
            УровеньЖурналаРегистрации.Ошибка,
            ,
            ,
            "Ошибка атомарной отправки: " + ОписаниеОшибки());

        ВызватьИсключение;
    КонецПопытки;

КонецПроцедуры
```

---

## Сценарий 2: Read-Process-Write (Exactly-Once обработка)

**Задача:** Прочитать сообщение из одного топика, обработать его и записать результат в другой топик с гарантией exactly-once.

**Важно:** Это самый популярный паттерн использования транзакций.

```1c
Процедура ОбработатьСообщенияExactlyOnce()

    Попытка
        // Создаем ОДИН экземпляр компоненты для консьюмера и продюсера
        // ВАЖНО: оба должны быть в одном экземпляре для метода ОтправитьОфсетыВТранзакцию
        Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");

        // ОБЯЗАТЕЛЬНЫЕ настройки для консьюмера
        Компонента.УстановитьПараметр("group.id", "processor-group");
        Компонента.УстановитьПараметр("isolation.level", "read_committed"); // Читаем только зафиксированные сообщения!
        Компонента.УстановитьПараметр("enable.auto.commit", "false"); // Отключаем автокоммит
        Компонента.УстановитьПараметр("enable.auto.offset.store", "false");

        // Инициализируем консьюмера
        Компонента.ИнициализироватьКонсьюмера("localhost:9092");
        Компонента.Подписаться("input-topic");
        Компонента.УстановитьТаймаутОжидания(1000);

        // Очищаем параметры для продюсера и устанавливаем новые
        Компонента.УстановитьПараметр("acks", "all");

        // Инициализируем транзакционного продюсера в том же экземпляре
        Если НЕ Компонента.ИнициализироватьТранзакционногоПродюсера("localhost:9092", "processor-producer-1") Тогда
            ВызватьИсключение "Ошибка инициализации продюсера: " + Компонента.ПолучитьСообщениеОбОшибке();
        КонецЕсли;

        РазрешеноОбрабатывать = Истина;

        Пока РазрешеноОбрабатывать Цикл

            // Читаем сообщение
            ЕстьСообщение = Компонента.ПрочитатьСообщение();

            Если ЕстьСообщение Тогда

                // Получаем данные сообщения
                Данные = Компонента.ПолучитьДанныеСообщения(Ложь);
                Топик = Компонента.ПолучитьТопикСообщения();
                Партиция = Компонента.ПолучитьРазделСообщения();
                Офсет = Компонента.ПолучитьСмещениеСообщения();

                // Начинаем транзакцию
                Если НЕ Компонента.НачатьТранзакцию() Тогда
                    ВызватьИсключение "Ошибка начала транзакции: " + Компонента.ПолучитьСообщениеОбОшибке();
                КонецЕсли;

                Попытка
                    // Обрабатываем данные (ваша бизнес-логика)
                    ОбработанныеДанные = ОбработатьСообщение(Данные);

                    // Отправляем результат в выходной топик
                    РезультатОтправки = Компонента.ОтправитьСообщение(
                        ОбработанныеДанные,
                        "output-topic",
                        ,
                        "",
                        ""
                    );

                    Если РезультатОтправки < 0 Тогда
                        ВызватьИсключение "Ошибка отправки: " + Компонента.ПолучитьСообщениеОбОшибке();
                    КонецЕсли;

                    // КРИТИЧЕСКИ ВАЖНО: Сохраняем офсет в транзакцию
                    // Указываем офсет СЛЕДУЮЩЕГО сообщения (текущий + 1)
                    ОфсетыJSON = СтрШаблон(
                        "{""offsets"": [{""topic"": ""%1"", ""partition"": %2, ""offset"": %3}]}",
                        Топик,
                        Партиция,
                        Офсет + 1
                    );

                    Если НЕ Компонента.ОтправитьОфсетыВТранзакцию(ОфсетыJSON, "processor-group") Тогда
                        ВызватьИсключение "Ошибка сохранения офсета: " + Компонента.ПолучитьСообщениеОбОшибке();
                    КонецЕсли;

                    // Фиксируем транзакцию
                    Если НЕ Компонента.ЗафиксироватьТранзакцию() Тогда
                        ВызватьИсключение "Ошибка фиксации: " + Компонента.ПолучитьСообщениеОбОшибке();
                    КонецЕсли;

                    // Транзакция успешно зафиксирована!
                    // Сообщение обработано exactly-once

                Исключение
                    // При ошибке откатываем транзакцию
                    Компонента.ОтменитьТранзакцию();

                    // Сообщение будет прочитано заново при следующей итерации
                    ЗаписьЖурналаРегистрации("Обработка Kafka",
                        УровеньЖурналаРегистрации.Предупреждение,
                        ,
                        ,
                        "Ошибка обработки сообщения, транзакция откачена: " + ОписаниеОшибки());
                КонецПопытки;

            КонецЕсли;

            // Проверяем условие остановки
            РазрешеноОбрабатывать = ПроверитьФлагОстановки();

        КонецЦикла;

        // Корректное завершение
        Компонента.ОстановитьКонсьюмера();
        Компонента.ОстановитьПродюсера();

    Исключение
        ЗаписьЖурналаРегистрации("Обработка Kafka",
            УровеньЖурналаРегистрации.Ошибка,
            ,
            ,
            "Критическая ошибка обработки: " + ОписаниеОшибки());

        ВызватьИсключение;
    КонецПопытки;

КонецПроцедуры

Функция ОбработатьСообщение(Данные)
    // Здесь ваша бизнес-логика обработки
    // Например, парсинг JSON, валидация, обогащение данных и т.д.

    ПарсерJSON = Новый ЧтениеJSON;
    ПарсерJSON.УстановитьСтроку(Данные);
    ДанныеСтруктура = ПрочитатьJSON(ПарсерJSON);

    // Обработка...
    ДанныеСтруктура.Вставить("processed", Истина);
    ДанныеСтруктура.Вставить("processedAt", ТекущаяДата());

    ЗаписьJSON = Новый ЗаписьJSON;
    ЗаписьJSON.УстановитьСтроку();
    ЗаписатьJSON(ЗаписьJSON, ДанныеСтруктура);

    Возврат ЗаписьJSON.Закрыть();
КонецФункции
```

---

## Сценарий 3: Пакетная обработка сообщений

**Задача:** Обработать пакет сообщений и зафиксировать результаты одной транзакцией.

```1c
Процедура ОбработатьПакетСообщений(РазмерПакета = 100)

    Попытка
        Консьюмер = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
        Консьюмер.УстановитьПараметр("group.id", "batch-processor");
        Консьюмер.УстановитьПараметр("isolation.level", "read_committed");
        Консьюмер.УстановитьПараметр("enable.auto.commit", "false");
        Консьюмер.УстановитьПараметр("enable.auto.offset.store", "false");

        Консьюмер.ИнициализироватьКонсьюмера("localhost:9092");
        Консьюмер.Подписаться("input-topic");

        Продюсер = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
        Продюсер.ИнициализироватьТранзакционногоПродюсера("localhost:9092", "batch-producer-1");

        РазрешеноОбрабатывать = Истина;

        Пока РазрешеноОбрабатывать Цикл

            // Собираем пакет сообщений
            ПакетСообщений = Новый Массив;
            ПоследнийОфсет = Неопределено;
            ПоследняяПартиция = Неопределено;
            ПоследнийТопик = Неопределено;

            Для Индекс = 1 По РазмерПакета Цикл
                ЕстьСообщение = Консьюмер.ПрочитатьСообщение();

                Если ЕстьСообщение Тогда
                    Сообщение = Новый Структура;
                    Сообщение.Вставить("Данные", Консьюмер.ПолучитьДанныеСообщения(Ложь));
                    Сообщение.Вставить("Топик", Консьюмер.ПолучитьТопикСообщения());
                    Сообщение.Вставить("Партиция", Консьюмер.ПолучитьРазделСообщения());
                    Сообщение.Вставить("Офсет", Консьюмер.ПолучитьСмещениеСообщения());

                    ПакетСообщений.Добавить(Сообщение);

                    ПоследнийТопик = Сообщение.Топик;
                    ПоследняяПартиция = Сообщение.Партиция;
                    ПоследнийОфсет = Сообщение.Офсет;
                Иначе
                    Прервать; // Нет больше сообщений
                КонецЕсли;
            КонецЦикла;

            // Если есть сообщения для обработки
            Если ПакетСообщений.Количество() > 0 Тогда

                // Начинаем транзакцию для всего пакета
                Продюсер.НачатьТранзакцию();

                Попытка
                    // Обрабатываем все сообщения пакета
                    Для Каждого Сообщение Из ПакетСообщений Цикл
                        ОбработанныеДанные = ОбработатьСообщение(Сообщение.Данные);

                        РезультатОтправки = Продюсер.ОтправитьСообщение(
                            ОбработанныеДанные,
                            "output-topic",
                            ,
                            "",
                            ""
                        );

                        Если РезультатОтправки < 0 Тогда
                            ВызватьИсключение "Ошибка отправки";
                        КонецЕсли;
                    КонецЦикла;

                    // Сохраняем офсет последнего сообщения + 1
                    ОфсетыJSON = СтрШаблон(
                        "{""offsets"": [{""topic"": ""%1"", ""partition"": %2, ""offset"": %3}]}",
                        ПоследнийТопик,
                        ПоследняяПартиция,
                        ПоследнийОфсет + 1
                    );

                    Продюсер.ОтправитьОфсетыВТранзакцию(ОфсетыJSON, "batch-processor");

                    // Фиксируем транзакцию - весь пакет обработан атомарно
                    Продюсер.ЗафиксироватьТранзакцию();

                    Сообщить(СтрШаблон("Пакет из %1 сообщений успешно обработан", ПакетСообщений.Количество()));

                Исключение
                    // Откатываем весь пакет
                    Продюсер.ОтменитьТранзакцию();

                    ЗаписьЖурналаРегистрации("Пакетная обработка",
                        УровеньЖурналаРегистрации.Предупреждение,
                        ,
                        ,
                        "Ошибка обработки пакета: " + ОписаниеОшибки());
                КонецПопытки;

            КонецЕсли;

            РазрешеноОбрабатывать = ПроверитьФлагОстановки();

        КонецЦикла;

        Консьюмер.ОстановитьКонсьюмера();
        Продюсер.ОстановитьПродюсера();

    Исключение
        ЗаписьЖурналаРегистрации("Пакетная обработка",
            УровеньЖурналаРегистрации.Ошибка,
            ,
            ,
            "Критическая ошибка: " + ОписаниеОшибки());
    КонецПопытки;

КонецПроцедуры
```

---

## Сценарий 4: Обработка ошибок и откат

**Задача:** Корректная обработка различных типов ошибок с откатом транзакций.

```1c
Процедура ОбработкаСОшибками()

    Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
    Компонента.ИнициализироватьТранзакционногоПродюсера("localhost:9092", "error-handler-1");

    МаксимальноПопыток = 3;
    ТекущаяПопытка = 0;

    Пока ТекущаяПопытка < МаксимальноПопыток Цикл

        ТекущаяПопытка = ТекущаяПопытка + 1;

        Попытка
            // Начинаем транзакцию
            Если НЕ Компонента.НачатьТранзакцию() Тогда
                ВызватьИсключение "Ошибка начала транзакции: " + Компонента.ПолучитьСообщениеОбОшибке();
            КонецЕсли;

            // Отправка сообщений
            Для Индекс = 1 По 10 Цикл
                СообщениеJSON = ПолучитьСообщение(Индекс);

                РезультатОтправки = Компонента.ОтправитьСообщение(
                    СообщениеJSON,
                    "my-topic",
                    ,
                    "",
                    ""
                );

                Если РезультатОтправки < 0 Тогда
                    // Специфическая ошибка отправки
                    ТекстОшибки = Компонента.ПолучитьСообщениеОбОшибке();

                    Если СтрНайти(ТекстОшибки, "Message size too large") > 0 Тогда
                        // Сообщение слишком большое - не имеет смысла повторять
                        ВызватьИсключение "Сообщение слишком большое, пропускаем";
                    ИначеЕсли СтрНайти(ТекстОшибки, "Topic not found") > 0 Тогда
                        // Топик не существует - критическая ошибка
                        ВызватьИсключение "Топик не найден, останавливаем обработку";
                    Иначе
                        // Временная ошибка - можно повторить
                        ВызватьИсключение "Временная ошибка отправки: " + ТекстОшибки;
                    КонецЕсли;
                КонецЕсли;
            КонецЦикла;

            // Фиксируем транзакцию
            Если НЕ Компонента.ЗафиксироватьТранзакцию() Тогда
                ТекстОшибки = Компонента.ПолучитьСообщениеОбОшибке();

                Если СтрНайти(ТекстОшибки, "Transaction timeout") > 0 Тогда
                    // Таймаут транзакции - можно повторить
                    ВызватьИсключение "Таймаут транзакции, повторяем";
                Иначе
                    // Другая ошибка фиксации
                    ВызватьИсключение "Ошибка фиксации: " + ТекстОшибки;
                КонецЕсли;
            КонецЕсли;

            // Успешно!
            Сообщить("Транзакция успешно зафиксирована");
            Прервать; // Выходим из цикла повторов

        Исключение
            ТекстОшибки = ОписаниеОшибки();

            // Откатываем транзакцию
            Попытка
                Компонента.ОтменитьТранзакцию();
                Сообщить(СтрШаблон("Транзакция откачена. Попытка %1 из %2", ТекущаяПопытка, МаксимальноПопыток));
            Исключение
                ЗаписьЖурналаРегистрации("Транзакции",
                    УровеньЖурналаРегистрации.Ошибка,
                    ,
                    ,
                    "Ошибка отката транзакции: " + ОписаниеОшибки());
            КонецПопытки;

            // Если это последняя попытка - прокидываем ошибку дальше
            Если ТекущаяПопытка >= МаксимальноПопыток Тогда
                ЗаписьЖурналаРегистрации("Транзакции",
                    УровеньЖурналаРегистрации.Ошибка,
                    ,
                    ,
                    "Исчерпаны все попытки: " + ТекстОшибки);
                ВызватьИсключение;
            КонецЕсли;

            // Задержка перед повтором (exponential backoff)
            ЗадержкаМС = 1000 * Pow(2, ТекущаяПопытка - 1); // 1с, 2с, 4с
            Компонента.Пауза(ЗадержкаМС);

        КонецПопытки;

    КонецЦикла;

КонецПроцедуры
```

---

## Сценарий 5: Интеграция с базой данных

**Задача:** Атомарно записать данные в базу данных 1С и в Kafka.

> **Внимание:** Это упрощенный пример. Полная атомарность между БД и Kafka требует дополнительной логики (idempotence keys, deduplication).

```1c
Процедура ЗаписатьВБДИKafka(ДанныеДокумента)

    НачатьТранзакцию(); // Транзакция 1С

    Попытка
        // 1. Записываем в базу данных 1С
        Документ = Документы.Заказ.СоздатьДокумент();
        ЗаполнитьЗначенияСвойств(Документ, ДанныеДокумента);
        Документ.Записать(РежимЗаписиДокумента.Проведение);

        // 2. Формируем сообщение для Kafka
        СообщениеJSON = СериализоватьВJSON(Документ);

        // 3. Отправляем в Kafka в рамках транзакции
        Компонента = Новый("AddIn.SimpleKafka1C.SimpleKafka1C");
        Компонента.ИнициализироватьТранзакционногоПродюсера("localhost:9092", "db-sync-producer-1");

        Компонента.НачатьТранзакцию();

        Попытка
            РезультатОтправки = Компонента.ОтправитьСообщение(
                СообщениеJSON,
                "orders-topic",
                ,
                Строка(Документ.Ссылка.УникальныйИдентификатор()),
                ""
            );

            Если РезультатОтправки < 0 Тогда
                ВызватьИсключение "Ошибка отправки в Kafka: " + Компонента.ПолучитьСообщениеОбОшибке();
            КонецЕсли;

            // Фиксируем транзакцию Kafka
            Если НЕ Компонента.ЗафиксироватьТранзакцию() Тогда
                ВызватьИсключение "Ошибка фиксации транзакции Kafka: " + Компонента.ПолучитьСообщениеОбОшибке();
            КонецЕсли;

            // Фиксируем транзакцию БД только если Kafka успешно
            ЗафиксироватьТранзакцию();

            Сообщить("Документ успешно записан в БД и Kafka");

        Исключение
            // Откатываем Kafka
            Компонента.ОтменитьТранзакцию();
            ВызватьИсключение;
        КонецПопытки;

    Исключение
        // Откатываем БД
        ОтменитьТранзакцию();

        ЗаписьЖурналаРегистрации("Синхронизация БД-Kafka",
            УровеньЖурналаРегистрации.Ошибка,
            ,
            ,
            "Ошибка записи: " + ОписаниеОшибки());

        ВызватьИсключение;
    КонецПопытки;

КонецПроцедуры
```

---

## Рекомендации и best practices

### 1. Уникальные transactional.id

```1c
// ПЛОХО: статический ID
ТранзакционныйID = "my-producer";

// ХОРОШО: уникальный ID для каждого экземпляра
ТранзакционныйID = СтрШаблон("my-producer-%1-%2",
    ИмяКомпьютера(),
    Формат(ТекущаяУниверсальнаяДата(), "ДФ='yyyyMMddHHmmss'")
);
```

### 2. Обработка timeout

```1c
// Увеличьте таймауты если сообщения большие
Компонента.УстановитьПараметр("transaction.timeout.ms", "120000"); // 2 минуты
```

### 3. Мониторинг

```1c
// Логируйте важные события
ЗаписьЖурналаРегистрации("Транзакции Kafka",
    УровеньЖурналаРегистрации.Информация,
    ,
    ,
    СтрШаблон("Транзакция зафиксирована, обработано сообщений: %1, время: %2 мс", Счетчик, Длительность));
```

### 4. Graceful shutdown

```1c
// При остановке приложения корректно завершайте продюсера
Попытка
    Если ТранзакцияАктивна Тогда
        Компонента.ОтменитьТранзакцию();
    КонецЕсли;
    Компонента.ОстановитьПродюсера();
Исключение
    // Логируем
КонецПопытки;
```

---

## Тестирование

Для тестирования транзакций рекомендуется:

1. Использовать локальный Kafka (Docker)
2. Симулировать различные типы ошибок
3. Проверять, что консьюмеры видят только зафиксированные сообщения
4. Тестировать восстановление после сбоев

Пример Docker Compose для локального тестирования:

```yaml
version: '3'
services:
  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
    ports:
      - "9092:9092"
```

---

## Дополнительная информация

- [Основная документация по транзакциям](../transactions.md)
- [Документация по продюсеру](../producer.md)
- [Документация по консьюмеру](../consumer.md)
